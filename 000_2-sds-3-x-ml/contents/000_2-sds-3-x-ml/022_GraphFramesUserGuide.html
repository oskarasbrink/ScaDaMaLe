<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>022_GraphFramesUserGuide</title>


        <!-- Custom HTML head -->

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../../contents/000_2-sds-3-x-ml/010a_packageCells.html">010a_packageCells</a></li><li class="chapter-item expanded affix "><a href="../../contents/000_2-sds-3-x-ml/011_02_IntroToSimulation.html">011_02_IntroToSimulation</a></li><li class="chapter-item expanded affix "><a href="../../contents/000_2-sds-3-x-ml/011_03_IntroToML.html">011_03_IntroToML</a></li><li class="chapter-item expanded affix "><a href="../../contents/000_2-sds-3-x-ml/012_UnsupervisedClustering_1MSongsKMeans_Intro.html">012_UnsupervisedClustering_1MSongsKMeans_Intro</a></li><li class="chapter-item expanded affix "><a href="../../contents/000_2-sds-3-x-ml/013_UnsupervisedClustering_1MSongsKMeans_Stage1ETL.html">013_UnsupervisedClustering_1MSongsKMeans_Stage1ETL</a></li><li class="chapter-item expanded affix "><a href="../../contents/000_2-sds-3-x-ml/014_UnsupervisedClustering_1MSongsKMeans_Stage2Explore.html">014_UnsupervisedClustering_1MSongsKMeans_Stage2Explore</a></li><li class="chapter-item expanded affix "><a href="../../contents/000_2-sds-3-x-ml/015_UnsupervisedClustering_1MSongsKMeans_Stage3Model.html">015_UnsupervisedClustering_1MSongsKMeans_Stage3Model</a></li><li class="chapter-item expanded affix "><a href="../../contents/000_2-sds-3-x-ml/016_SupervisedClustering_DecisionTrees_HandWrittenDigitRecognition.html">016_SupervisedClustering_DecisionTrees_HandWrittenDigitRecognition</a></li><li class="chapter-item expanded affix "><a href="../../contents/000_2-sds-3-x-ml/017_LAlgIntro.html">017_LAlgIntro</a></li><li class="chapter-item expanded affix "><a href="../../contents/000_2-sds-3-x-ml/018_LinRegIntro.html">018_LinRegIntro</a></li><li class="chapter-item expanded affix "><a href="../../contents/000_2-sds-3-x-ml/019_DistLAlgForLinRegIntro.html">019_DistLAlgForLinRegIntro</a></li><li class="chapter-item expanded affix "><a href="../../contents/000_2-sds-3-x-ml/019x_000_dataTypesProgGuide.html">019x_000_dataTypesProgGuide</a></li><li class="chapter-item expanded affix "><a href="../../contents/000_2-sds-3-x-ml/019x_001_LocalVector.html">019x_001_LocalVector</a></li><li class="chapter-item expanded affix "><a href="../../contents/000_2-sds-3-x-ml/019x_002_LabeledPoint.html">019x_002_LabeledPoint</a></li><li class="chapter-item expanded affix "><a href="../../contents/000_2-sds-3-x-ml/019x_003_LocalMatrix.html">019x_003_LocalMatrix</a></li><li class="chapter-item expanded affix "><a href="../../contents/000_2-sds-3-x-ml/019x_004_DistributedMatrix.html">019x_004_DistributedMatrix</a></li><li class="chapter-item expanded affix "><a href="../../contents/000_2-sds-3-x-ml/019x_005_RowMatrix.html">019x_005_RowMatrix</a></li><li class="chapter-item expanded affix "><a href="../../contents/000_2-sds-3-x-ml/019x_006_IndexedRowMatrix.html">019x_006_IndexedRowMatrix</a></li><li class="chapter-item expanded affix "><a href="../../contents/000_2-sds-3-x-ml/019x_007_CoordinateMatrix.html">019x_007_CoordinateMatrix</a></li><li class="chapter-item expanded affix "><a href="../../contents/000_2-sds-3-x-ml/019x_008_BlockMatrix.html">019x_008_BlockMatrix</a></li><li class="chapter-item expanded affix "><a href="../../contents/000_2-sds-3-x-ml/020_PowerPlantPipeline_02ModelTuneEvaluate.html">020_PowerPlantPipeline_02ModelTuneEvaluate</a></li><li class="chapter-item expanded affix "><a href="../../contents/000_2-sds-3-x-ml/021_recognizeActivityByRandomForest.html">021_recognizeActivityByRandomForest</a></li><li class="chapter-item expanded affix "><a href="../../contents/000_2-sds-3-x-ml/022_GraphFramesUserGuide.html" class="active">022_GraphFramesUserGuide</a></li><li class="chapter-item expanded affix "><a href="../../contents/000_2-sds-3-x-ml/023_OnTimeFlightPerformance.html">023_OnTimeFlightPerformance</a></li><li class="chapter-item expanded affix "><a href="../../contents/000_2-sds-3-x-ml/030_PowerPlantPipeline_03ModelTuneEvaluateDeploy.html">030_PowerPlantPipeline_03ModelTuneEvaluateDeploy</a></li><li class="chapter-item expanded affix "><a href="../../contents/000_2-sds-3-x-ml/036_ALS_MovieRecommender.html">036_ALS_MovieRecommender</a></li><li class="chapter-item expanded affix "><a href="../../contents/000_2-sds-3-x-ml/998_EX_01_GraphXShortestWeightedPaths.html">998_EX_01_GraphXShortestWeightedPaths</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <div class="cell markdown">
<p>ScaDaMaLe Course <a href="https://lamastex.github.io/scalable-data-science/sds/3/x/">site</a> and <a href="https://lamastex.github.io/ScaDaMaLe/index.html">book</a></p>
</div>
<div class="cell markdown">
<h2 id="distributed-vertex-programming-using-graphx"><a class="header" href="#distributed-vertex-programming-using-graphx">Distributed Vertex Programming using GraphX</a></h2>
<p>This is an augmentation of <a href="http://go.databricks.com/hubfs/notebooks/3-GraphFrames-User-Guide-scala.html">http://go.databricks.com/hubfs/notebooks/3-GraphFrames-User-Guide-scala.html</a> that was last retrieved in 2019.</p>
<p>See:</p>
<ul>
<li><a href="https://amplab.cs.berkeley.edu/wp-content/uploads/2014/09/graphx.pdf">https://amplab.cs.berkeley.edu/wp-content/uploads/2014/09/graphx.pdf</a></li>
<li><a href="https://amplab.github.io/graphx/">https://amplab.github.io/graphx/</a></li>
<li><a href="https://spark.apache.org/docs/latest/graphx-programming-guide.html">https://spark.apache.org/docs/latest/graphx-programming-guide.html</a></li>
<li><a href="https://databricks.com/blog/2016/03/03/introducing-graphframes.html">https://databricks.com/blog/2016/03/03/introducing-graphframes.html</a></li>
<li><a href="https://databricks.com/blog/2016/03/16/on-time-flight-performance-with-spark-graphframes.html">https://databricks.com/blog/2016/03/16/on-time-flight-performance-with-spark-graphframes.html</a></li>
<li><a href="http://ampcamp.berkeley.edu/big-data-mini-course/graph-analytics-with-graphx.html">http://ampcamp.berkeley.edu/big-data-mini-course/graph-analytics-with-graphx.html</a></li>
</ul>
<p>And of course the databricks guide: * <a href="https://docs.databricks.com/spark/latest/graph-analysis/index.html">https://docs.databricks.com/spark/latest/graph-analysis/index.html</a></p>
<p><em>Use the source, Luke/Lea!</em></p>
<ul>
<li><a href="https://github.com/graphframes/graphframes">https://github.com/graphframes/graphframes</a></li>
</ul>
</div>
<div class="cell markdown">
<h2 id="community-packages-in-spark---more-generally"><a class="header" href="#community-packages-in-spark---more-generally">Community Packages in Spark - more generally</a></h2>
<p>Let us recall the following quoate in Chapter 10 of <em>High Performance Spark</em> book (needs access to Orielly publishers via your library/subscription): - https://learning.oreilly.com/library/view/high-performance-spark/9781491943199/ch10.html#components</p>
<blockquote>
<p>Beyond the integrated components, the community packages can add important functionality to Spark, sometimes even superseding built-in functionality—like with GraphFrames.</p>
</blockquote>
<p>Here we introduce you to GraphFrames quickly so you don't need to drop down to the GraphX library that requires more understanding of caching and checkpointing to keep the vertex program's DAG from exploding or becoming inefficient.</p>
</div>
<div class="cell code" execution_count="1" scrolled="auto">
<div class="output execute_result html_result" execution_count="1">
<iframe 
 src="https://amplab.github.io/graphx/"
 width="95%" height="700"
 sandbox>
  <p>
    <a href="http://spark.apache.org/docs/latest/index.html">
      Fallback link for browsers that, unlikely, don't support frames
    </a>
  </p>
</iframe>
</div>
</div>
<div class="cell code" execution_count="1" scrolled="auto">
<div class="output execute_result html_result" execution_count="1">
<iframe 
 src="https://spark.apache.org/docs/latest/graphx-programming-guide.html#optimized-representation"
 width="95%" height="800"
 sandbox>
  <p>
    <a href="http://spark.apache.org/docs/latest/index.html">
      Fallback link for browsers that, unlikely, don't support frames
    </a>
  </p>
</iframe>
</div>
</div>
<div class="cell markdown">
<h1 id="graphframes-user-guide-scala"><a class="header" href="#graphframes-user-guide-scala">GraphFrames User Guide (Scala)</a></h1>
<p>GraphFrames is a package for Apache Spark which provides DataFrame-based Graphs. It provides high-level APIs in Scala, Java, and Python. It aims to provide both the functionality of GraphX and extended functionality taking advantage of Spark DataFrames. This extended functionality includes motif finding, DataFrame-based serialization, and highly expressive graph queries.</p>
<p>The GraphFrames package is available from <a href="http://spark-packages.org/package/graphframes/graphframes">Spark Packages</a>.</p>
<p>This notebook demonstrates examples from the GraphFrames User Guide: <a href="https://graphframes.github.io/graphframes/docs/_site/user-guide.html">https://graphframes.github.io/graphframes/docs/_site/user-guide.html</a>.</p>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-scala">sc.version // link the right library depending on Spark version of the cluster that's running
// spark version 2.3.0 works with graphframes:graphframes:0.7.0-spark2.3-s_2.11
// spark version 3.0.1 works with graphframes:graphframes:0.8.1-spark3.0-s_2.12
</code></pre>
<div class="output execute_result plain_result" execution_count="1">
<pre><code>res0: String = 3.1.2
</code></pre>
</div>
</div>
<div class="cell markdown">
<p>Since databricks.com stopped allowing IFrame embeds we have to open it in a separate window now. The blog is insightful and worth a perusal:</p>
<ul>
<li>https://databricks.com/blog/2016/03/03/introducing-graphframes.html</li>
</ul>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-scala">// we first need to install the library - graphframes as a Spark package - and attach it to our cluster - see note two cells above!
import org.apache.spark.sql._
import org.apache.spark.sql.functions._

import org.graphframes._
</code></pre>
<div class="output execute_result plain_result" execution_count="1">
<pre><code>import org.apache.spark.sql._
import org.apache.spark.sql.functions._
import org.graphframes._
</code></pre>
</div>
</div>
<div class="cell markdown">
<h2 id="creating-graphframes"><a class="header" href="#creating-graphframes">Creating GraphFrames</a></h2>
<p>Let us try to create an example social network from the blog: * <a href="https://databricks.com/blog/2016/03/03/introducing-graphframes.html">https://databricks.com/blog/2016/03/03/introducing-graphframes.html</a>.</p>
<p><img src="https://databricks.com/wp-content/uploads/2016/03/social-network-graph-diagram.png" alt="" /></p>
<p>Users can create GraphFrames from vertex and edge DataFrames.</p>
<ul>
<li><strong>Vertex DataFrame:</strong> A vertex DataFrame should contain a special column named <code>id</code> which specifies unique IDs for each vertex in the graph.</li>
<li><strong>Edge DataFrame:</strong> An edge DataFrame should contain two special columns: <code>src</code> (source vertex ID of edge) and <code>dst</code> (destination vertex ID of edge).</li>
</ul>
<p>Both DataFrames can have arbitrary other columns. Those columns can represent vertex and edge attributes.</p>
<p>In our example, we can use a GraphFrame can store data or properties associated with each vertex and edge.</p>
<p>In our social network, each user might have an age and name, and each connection might have a relationship type.</p>
</div>
<div class="cell markdown">
<p>Create the vertices and edges</p>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-scala">// Vertex DataFrame
val v = sqlContext.createDataFrame(List(
  (&quot;a&quot;, &quot;Alice&quot;, 34),
  (&quot;b&quot;, &quot;Bob&quot;, 36),
  (&quot;c&quot;, &quot;Charlie&quot;, 30),
  (&quot;d&quot;, &quot;David&quot;, 29),
  (&quot;e&quot;, &quot;Esther&quot;, 32),
  (&quot;f&quot;, &quot;Fanny&quot;, 36),
  (&quot;g&quot;, &quot;Gabby&quot;, 60)
)).toDF(&quot;id&quot;, &quot;name&quot;, &quot;age&quot;)

// Edge DataFrame
val e = sqlContext.createDataFrame(List(
  (&quot;a&quot;, &quot;b&quot;, &quot;friend&quot;),
  (&quot;b&quot;, &quot;c&quot;, &quot;follow&quot;),
  (&quot;c&quot;, &quot;b&quot;, &quot;follow&quot;),
  (&quot;f&quot;, &quot;c&quot;, &quot;follow&quot;),
  (&quot;e&quot;, &quot;f&quot;, &quot;follow&quot;),
  (&quot;e&quot;, &quot;d&quot;, &quot;friend&quot;),
  (&quot;d&quot;, &quot;a&quot;, &quot;friend&quot;),
  (&quot;a&quot;, &quot;e&quot;, &quot;friend&quot;)
)).toDF(&quot;src&quot;, &quot;dst&quot;, &quot;relationship&quot;)
</code></pre>
<div class="output execute_result plain_result" execution_count="1">
<pre><code>v: org.apache.spark.sql.DataFrame = [id: string, name: string ... 1 more field]
e: org.apache.spark.sql.DataFrame = [src: string, dst: string ... 1 more field]
</code></pre>
</div>
</div>
<div class="cell markdown">
<p>Let's create a graph from these vertices and these edges:</p>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-scala">val g = GraphFrame(v, e)
</code></pre>
<div class="output execute_result plain_result" execution_count="1">
<pre><code>g: org.graphframes.GraphFrame = GraphFrame(v:[id: string, name: string ... 1 more field], e:[src: string, dst: string ... 1 more field])
</code></pre>
</div>
</div>
<div class="cell markdown">
<p>Let's use the d3.graphs to visualise graphs (recall the D3 graphs in wiki-click example). You need the <code>Run Cell</code> below using that cell's <em>Play</em> button's drop-down menu.</p>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<div class="output execute_result plain_result" execution_count="1">
<pre><code>Warning: classes defined within packages cannot be redefined without a cluster restart.
Compilation successful.
</code></pre>
</div>
</div>
<div class="cell code" execution_count="1" scrolled="auto">
<pre><code class="language-scala">d3.graphs.help()
</code></pre>
<div class="output execute_result html_result" execution_count="1">
<p>
Produces a force-directed graph given a collection of edges of the following form:</br>
<tt><font color="#a71d5d">case class</font> <font color="#795da3">Edge</font>(<font color="#ed6a43">src</font>: <font color="#a71d5d">String</font>, <font color="#ed6a43">dest</font>: <font color="#a71d5d">String</font>, <font color="#ed6a43">count</font>: <font color="#a71d5d">Long</font>)</tt>
</p>
<p>Usage:<br/>
<tt><font color="#a71d5d">import</font> <font color="#ed6a43">d3._</font></tt><br/>
<tt><font color="#795da3">graphs.force</font>(</br>
&nbsp;&nbsp;<font color="#ed6a43">height</font> = <font color="#795da3">500</font>,<br/>
&nbsp;&nbsp;<font color="#ed6a43">width</font> = <font color="#795da3">500</font>,<br/>
&nbsp;&nbsp;<font color="#ed6a43">clicks</font>: <font color="#795da3">Dataset</font>[<font color="#795da3">Edge</font>])</tt>
</p>
</div>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-scala">import org.apache.spark.sql.functions.lit // import the lit function in sql
val gE= g.edges.select($&quot;src&quot;, $&quot;dst&quot;.as(&quot;dest&quot;), lit(1L).as(&quot;count&quot;)) // for us the column count is just an edge incidence
</code></pre>
<div class="output execute_result plain_result" execution_count="1">
<pre><code>import org.apache.spark.sql.functions.lit
gE: org.apache.spark.sql.DataFrame = [src: string, dest: string ... 1 more field]
</code></pre>
</div>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-scala">display(gE)
</code></pre>
<div class="output execute_result tabular_result" execution_count="1">
<table>
<thead>
<tr class="header">
<th>src</th>
<th>dest</th>
<th>count</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>a</td>
<td>b</td>
<td>1.0</td>
</tr>
<tr class="even">
<td>b</td>
<td>c</td>
<td>1.0</td>
</tr>
<tr class="odd">
<td>c</td>
<td>b</td>
<td>1.0</td>
</tr>
<tr class="even">
<td>f</td>
<td>c</td>
<td>1.0</td>
</tr>
<tr class="odd">
<td>e</td>
<td>f</td>
<td>1.0</td>
</tr>
<tr class="even">
<td>e</td>
<td>d</td>
<td>1.0</td>
</tr>
<tr class="odd">
<td>d</td>
<td>a</td>
<td>1.0</td>
</tr>
<tr class="even">
<td>a</td>
<td>e</td>
<td>1.0</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="cell code" execution_count="1" scrolled="auto">
<pre><code class="language-scala">d3.graphs.force(
  height = 500,
  width = 500,
  clicks = gE.as[d3.Edge])
</code></pre>
<div class="output execute_result html_result" execution_count="1">
<style>

.node_circle {
  stroke: #777;
  stroke-width: 1.3px;
}

.node_label {
  pointer-events: none;
}

.link {
  stroke: #777;
  stroke-opacity: .2;
}

.node_count {
  stroke: #777;
  stroke-width: 1.0px;
  fill: #999;
}

text.legend {
  font-family: Verdana;
  font-size: 13px;
  fill: #000;
}

.node text {
  font-family: "Helvetica Neue","Helvetica","Arial",sans-serif;
  font-size: 17px;
  font-weight: 200;
}

</style>
<div id="clicks-graph">
<script src="//d3js.org/d3.v3.min.js"></script>
<script>
<p>var graph = {&quot;nodes&quot;:[{&quot;name&quot;:&quot;e&quot;},{&quot;name&quot;:&quot;f&quot;},{&quot;name&quot;:&quot;a&quot;},{&quot;name&quot;:&quot;b&quot;},{&quot;name&quot;:&quot;c&quot;},{&quot;name&quot;:&quot;d&quot;}],&quot;links&quot;:[{&quot;source&quot;:2,&quot;target&quot;:3,&quot;value&quot;:1},{&quot;source&quot;:3,&quot;target&quot;:4,&quot;value&quot;:1},{&quot;source&quot;:4,&quot;target&quot;:3,&quot;value&quot;:1},{&quot;source&quot;:1,&quot;target&quot;:4,&quot;value&quot;:1},{&quot;source&quot;:0,&quot;target&quot;:1,&quot;value&quot;:1},{&quot;source&quot;:0,&quot;target&quot;:5,&quot;value&quot;:1},{&quot;source&quot;:5,&quot;target&quot;:2,&quot;value&quot;:1},{&quot;source&quot;:2,&quot;target&quot;:0,&quot;value&quot;:1}]};</p>
<p>var width = 500,
height = 500;</p>
<p>var color = d3.scale.category20();</p>
<p>var force = d3.layout.force()
.charge(-700)
.linkDistance(180)
.size([width, height]);</p>
<p>var svg = d3.select(&quot;#clicks-graph&quot;).append(&quot;svg&quot;)
.attr(&quot;width&quot;, width)
.attr(&quot;height&quot;, height);</p>
<p>force
.nodes(graph.nodes)
.links(graph.links)
.start();</p>
<p>var link = svg.selectAll(&quot;.link&quot;)
.data(graph.links)
.enter().append(&quot;line&quot;)
.attr(&quot;class&quot;, &quot;link&quot;)
.style(&quot;stroke-width&quot;, function(d) { return Math.sqrt(d.value); });</p>
<p>var node = svg.selectAll(&quot;.node&quot;)
.data(graph.nodes)
.enter().append(&quot;g&quot;)
.attr(&quot;class&quot;, &quot;node&quot;)
.call(force.drag);</p>
<p>node.append(&quot;circle&quot;)
.attr(&quot;r&quot;, 10)
.style(&quot;fill&quot;, function (d) {
if (d.name.startsWith(&quot;other&quot;)) { return color(1); } else { return color(2); };
})</p>
<p>node.append(&quot;text&quot;)
.attr(&quot;dx&quot;, 10)
.attr(&quot;dy&quot;, &quot;.35em&quot;)
.text(function(d) { return d.name });</p>
<p>//Now we are giving the SVGs co-ordinates - the force layout is generating the co-ordinates which this code is using to update the attributes of the SVG elements
force.on(&quot;tick&quot;, function () {
link.attr(&quot;x1&quot;, function (d) {
return d.source.x;
})
.attr(&quot;y1&quot;, function (d) {
return d.source.y;
})
.attr(&quot;x2&quot;, function (d) {
return d.target.x;
})
.attr(&quot;y2&quot;, function (d) {
return d.target.y;
});
d3.selectAll(&quot;circle&quot;).attr(&quot;cx&quot;, function (d) {
return d.x;
})
.attr(&quot;cy&quot;, function (d) {
return d.y;
});
d3.selectAll(&quot;text&quot;).attr(&quot;x&quot;, function (d) {
return d.x;
})
.attr(&quot;y&quot;, function (d) {
return d.y;
});
});
</script></p>
</div>
</div>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-scala">// This example graph also comes with the GraphFrames package.
val g0 = examples.Graphs.friends
</code></pre>
<div class="output execute_result plain_result" execution_count="1">
<pre><code>g0: org.graphframes.GraphFrame = GraphFrame(v:[id: string, name: string ... 1 more field], e:[src: string, dst: string ... 1 more field])
</code></pre>
</div>
</div>
<div class="cell code" execution_count="1" scrolled="auto">
<pre><code class="language-scala">d3.graphs.force( // let us see g0 now in one cell
  height = 500,
  width = 500,
  clicks = g0.edges.select($&quot;src&quot;, $&quot;dst&quot;.as(&quot;dest&quot;), lit(1L).as(&quot;count&quot;)).as[d3.Edge])
</code></pre>
<div class="output execute_result html_result" execution_count="1">
<style>

.node_circle {
  stroke: #777;
  stroke-width: 1.3px;
}

.node_label {
  pointer-events: none;
}

.link {
  stroke: #777;
  stroke-opacity: .2;
}

.node_count {
  stroke: #777;
  stroke-width: 1.0px;
  fill: #999;
}

text.legend {
  font-family: Verdana;
  font-size: 13px;
  fill: #000;
}

.node text {
  font-family: "Helvetica Neue","Helvetica","Arial",sans-serif;
  font-size: 17px;
  font-weight: 200;
}

</style>
<div id="clicks-graph">
<script src="//d3js.org/d3.v3.min.js"></script>
<script>
<p>var graph = {&quot;nodes&quot;:[{&quot;name&quot;:&quot;e&quot;},{&quot;name&quot;:&quot;f&quot;},{&quot;name&quot;:&quot;a&quot;},{&quot;name&quot;:&quot;b&quot;},{&quot;name&quot;:&quot;c&quot;},{&quot;name&quot;:&quot;d&quot;}],&quot;links&quot;:[{&quot;source&quot;:2,&quot;target&quot;:3,&quot;value&quot;:1},{&quot;source&quot;:3,&quot;target&quot;:4,&quot;value&quot;:1},{&quot;source&quot;:4,&quot;target&quot;:3,&quot;value&quot;:1},{&quot;source&quot;:1,&quot;target&quot;:4,&quot;value&quot;:1},{&quot;source&quot;:0,&quot;target&quot;:1,&quot;value&quot;:1},{&quot;source&quot;:0,&quot;target&quot;:5,&quot;value&quot;:1},{&quot;source&quot;:5,&quot;target&quot;:2,&quot;value&quot;:1},{&quot;source&quot;:2,&quot;target&quot;:0,&quot;value&quot;:1}]};</p>
<p>var width = 500,
height = 500;</p>
<p>var color = d3.scale.category20();</p>
<p>var force = d3.layout.force()
.charge(-700)
.linkDistance(180)
.size([width, height]);</p>
<p>var svg = d3.select(&quot;#clicks-graph&quot;).append(&quot;svg&quot;)
.attr(&quot;width&quot;, width)
.attr(&quot;height&quot;, height);</p>
<p>force
.nodes(graph.nodes)
.links(graph.links)
.start();</p>
<p>var link = svg.selectAll(&quot;.link&quot;)
.data(graph.links)
.enter().append(&quot;line&quot;)
.attr(&quot;class&quot;, &quot;link&quot;)
.style(&quot;stroke-width&quot;, function(d) { return Math.sqrt(d.value); });</p>
<p>var node = svg.selectAll(&quot;.node&quot;)
.data(graph.nodes)
.enter().append(&quot;g&quot;)
.attr(&quot;class&quot;, &quot;node&quot;)
.call(force.drag);</p>
<p>node.append(&quot;circle&quot;)
.attr(&quot;r&quot;, 10)
.style(&quot;fill&quot;, function (d) {
if (d.name.startsWith(&quot;other&quot;)) { return color(1); } else { return color(2); };
})</p>
<p>node.append(&quot;text&quot;)
.attr(&quot;dx&quot;, 10)
.attr(&quot;dy&quot;, &quot;.35em&quot;)
.text(function(d) { return d.name });</p>
<p>//Now we are giving the SVGs co-ordinates - the force layout is generating the co-ordinates which this code is using to update the attributes of the SVG elements
force.on(&quot;tick&quot;, function () {
link.attr(&quot;x1&quot;, function (d) {
return d.source.x;
})
.attr(&quot;y1&quot;, function (d) {
return d.source.y;
})
.attr(&quot;x2&quot;, function (d) {
return d.target.x;
})
.attr(&quot;y2&quot;, function (d) {
return d.target.y;
});
d3.selectAll(&quot;circle&quot;).attr(&quot;cx&quot;, function (d) {
return d.x;
})
.attr(&quot;cy&quot;, function (d) {
return d.y;
});
d3.selectAll(&quot;text&quot;).attr(&quot;x&quot;, function (d) {
return d.x;
})
.attr(&quot;y&quot;, function (d) {
return d.y;
});
});
</script></p>
</div>
</div>
</div>
<div class="cell markdown">
<h2 id="basic-graph-and-dataframe-queries"><a class="header" href="#basic-graph-and-dataframe-queries">Basic graph and DataFrame queries</a></h2>
<p>GraphFrames provide several simple graph queries, such as node degree.</p>
<p>Also, since GraphFrames represent graphs as pairs of vertex and edge DataFrames, it is easy to make powerful queries directly on the vertex and edge DataFrames. Those DataFrames are made available as vertices and edges fields in the GraphFrame.</p>
<h3 id="simple-queries-are-simple"><a class="header" href="#simple-queries-are-simple">Simple queries are simple</a></h3>
<p>GraphFrames make it easy to express queries over graphs. Since GraphFrame vertices and edges are stored as DataFrames, many queries are just DataFrame (or SQL) queries.</p>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-scala">display(g.vertices)
</code></pre>
<div class="output execute_result tabular_result" execution_count="1">
<table>
<thead>
<tr class="header">
<th>id</th>
<th>name</th>
<th>age</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>a</td>
<td>Alice</td>
<td>34.0</td>
</tr>
<tr class="even">
<td>b</td>
<td>Bob</td>
<td>36.0</td>
</tr>
<tr class="odd">
<td>c</td>
<td>Charlie</td>
<td>30.0</td>
</tr>
<tr class="even">
<td>d</td>
<td>David</td>
<td>29.0</td>
</tr>
<tr class="odd">
<td>e</td>
<td>Esther</td>
<td>32.0</td>
</tr>
<tr class="even">
<td>f</td>
<td>Fanny</td>
<td>36.0</td>
</tr>
<tr class="odd">
<td>g</td>
<td>Gabby</td>
<td>60.0</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-scala">display(g0.vertices) // this is the same query on the graph loaded as an example from GraphFrame package
</code></pre>
<div class="output execute_result tabular_result" execution_count="1">
<table>
<thead>
<tr class="header">
<th>id</th>
<th>name</th>
<th>age</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>a</td>
<td>Alice</td>
<td>34.0</td>
</tr>
<tr class="even">
<td>b</td>
<td>Bob</td>
<td>36.0</td>
</tr>
<tr class="odd">
<td>c</td>
<td>Charlie</td>
<td>30.0</td>
</tr>
<tr class="even">
<td>d</td>
<td>David</td>
<td>29.0</td>
</tr>
<tr class="odd">
<td>e</td>
<td>Esther</td>
<td>32.0</td>
</tr>
<tr class="even">
<td>f</td>
<td>Fanny</td>
<td>36.0</td>
</tr>
<tr class="odd">
<td>g</td>
<td>Gabby</td>
<td>60.0</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-scala">display(g.edges)
</code></pre>
<div class="output execute_result tabular_result" execution_count="1">
<table>
<thead>
<tr class="header">
<th>src</th>
<th>dst</th>
<th>relationship</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>a</td>
<td>b</td>
<td>friend</td>
</tr>
<tr class="even">
<td>b</td>
<td>c</td>
<td>follow</td>
</tr>
<tr class="odd">
<td>c</td>
<td>b</td>
<td>follow</td>
</tr>
<tr class="even">
<td>f</td>
<td>c</td>
<td>follow</td>
</tr>
<tr class="odd">
<td>e</td>
<td>f</td>
<td>follow</td>
</tr>
<tr class="even">
<td>e</td>
<td>d</td>
<td>friend</td>
</tr>
<tr class="odd">
<td>d</td>
<td>a</td>
<td>friend</td>
</tr>
<tr class="even">
<td>a</td>
<td>e</td>
<td>friend</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="cell markdown">
<p>The incoming degree of the vertices:</p>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-scala">display(g.inDegrees)
</code></pre>
<div class="output execute_result tabular_result" execution_count="1">
<table>
<thead>
<tr class="header">
<th>id</th>
<th>inDegree</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>c</td>
<td>2.0</td>
</tr>
<tr class="even">
<td>d</td>
<td>1.0</td>
</tr>
<tr class="odd">
<td>e</td>
<td>1.0</td>
</tr>
<tr class="even">
<td>b</td>
<td>2.0</td>
</tr>
<tr class="odd">
<td>f</td>
<td>1.0</td>
</tr>
<tr class="even">
<td>a</td>
<td>1.0</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="cell markdown">
<p>The outgoing degree of the vertices:</p>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-scala">display(g.outDegrees)
</code></pre>
<div class="output execute_result tabular_result" execution_count="1">
<table>
<thead>
<tr class="header">
<th>id</th>
<th>outDegree</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>a</td>
<td>2.0</td>
</tr>
<tr class="even">
<td>c</td>
<td>1.0</td>
</tr>
<tr class="odd">
<td>e</td>
<td>2.0</td>
</tr>
<tr class="even">
<td>d</td>
<td>1.0</td>
</tr>
<tr class="odd">
<td>b</td>
<td>1.0</td>
</tr>
<tr class="even">
<td>f</td>
<td>1.0</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="cell markdown">
<p>The degree of the vertices:</p>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-scala">display(g.degrees)
</code></pre>
<div class="output execute_result tabular_result" execution_count="1">
<table>
<thead>
<tr class="header">
<th>id</th>
<th>degree</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>b</td>
<td>3.0</td>
</tr>
<tr class="even">
<td>a</td>
<td>3.0</td>
</tr>
<tr class="odd">
<td>c</td>
<td>3.0</td>
</tr>
<tr class="even">
<td>f</td>
<td>2.0</td>
</tr>
<tr class="odd">
<td>e</td>
<td>3.0</td>
</tr>
<tr class="even">
<td>d</td>
<td>2.0</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="cell markdown">
<p>You can run queries directly on the vertices DataFrame. For example, we can find the age of the youngest person in the graph:</p>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-scala">val youngest = g.vertices.groupBy().min(&quot;age&quot;)
display(youngest)
</code></pre>
<div class="output execute_result tabular_result" execution_count="1">
<table>
<thead>
<tr class="header">
<th>min(age)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>29.0</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="cell markdown">
<p>Likewise, you can run queries on the edges DataFrame.</p>
<p>For example, let us count the number of 'follow' relationships in the graph:</p>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-scala">val numFollows = g.edges.filter(&quot;relationship = 'follow'&quot;).count()
</code></pre>
<div class="output execute_result plain_result" execution_count="1">
<pre><code>numFollows: Long = 4
</code></pre>
</div>
</div>
<div class="cell markdown">
<h2 id="motif-finding"><a class="header" href="#motif-finding">Motif finding</a></h2>
<p>More complex relationships involving edges and vertices can be built using motifs.</p>
<p>The following cell finds the pairs of vertices with edges in both directions between them.</p>
<p>The result is a dataframe, in which the column names are given by the motif keys.</p>
<p>Check out the GraphFrame User Guide at <a href="https://graphframes.github.io/graphframes/docs/_site/user-guide.html">https://graphframes.github.io/graphframes/docs/_site/user-guide.html</a> for more details on the API.</p>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-scala">// Search for pairs of vertices with edges in both directions between them, i.e., find undirected or bidirected edges.
val motifs = g.find(&quot;(a)-[e1]-&gt;(b); (b)-[e2]-&gt;(a)&quot;)
display(motifs)
</code></pre>
</div>
<div class="cell markdown">
<p>Since the result is a DataFrame, more complex queries can be built on top of the motif.</p>
<p>Let us find all the reciprocal relationships in which one person is older than 30:</p>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-scala">val filtered = motifs.filter(&quot;b.age &gt; 30&quot;)
display(filtered)
</code></pre>
</div>
<div class="cell markdown">
<p><strong>You Try!</strong></p>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-scala">//Search for all &quot;directed triangles&quot; or triplets of vertices: a,b,c with edges: a-&gt;b, b-&gt;c and c-&gt;a
//uncomment the next 2 lines and replace the &quot;XXX&quot; below
//val motifs3 = g.find(&quot;(a)-[e1]-&gt;(b); (b)-[e2]-&gt;(c); (c)-[e3]-&gt;(XXX)&quot;)
//display(motifs3)
</code></pre>
</div>
<div class="cell markdown">
<p><strong>Stateful queries</strong></p>
<p>Many motif queries are stateless and simple to express, as in the examples above. The next examples demonstrate more complex queries which carry state along a path in the motif. These queries can be expressed by combining GraphFrame motif finding with filters on the result, where the filters use sequence operations to construct a series of DataFrame Columns.</p>
<p>For example, suppose one wishes to identify a chain of 4 vertices with some property defined by a sequence of functions. That is, among chains of 4 vertices <code>a-&gt;b-&gt;c-&gt;d</code>, identify the subset of chains matching this complex filter:</p>
<ul>
<li>Initialize state on path.</li>
<li>Update state based on vertex a.</li>
<li>Update state based on vertex b.</li>
<li>Etc. for c and d.</li>
<li>If final state matches some condition, then the chain is accepted by the filter.</li>
</ul>
<p>The below code snippets demonstrate this process, where we identify chains of 4 vertices such that at least 2 of the 3 edges are <code>friend</code> relationships. In this example, the state is the current count of <code>friend</code> edges; in general, it could be any DataFrame Column.</p>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-scala">// Find chains of 4 vertices.
val chain4 = g.find(&quot;(a)-[ab]-&gt;(b); (b)-[bc]-&gt;(c); (c)-[cd]-&gt;(d)&quot;)

// Query on sequence, with state (cnt)
//  (a) Define method for updating state given the next element of the motif.
def sumFriends(cnt: Column, relationship: Column): Column = {
  when(relationship === &quot;friend&quot;, cnt + 1).otherwise(cnt)
}
//  (b) Use sequence operation to apply method to sequence of elements in motif.
//      In this case, the elements are the 3 edges.
val condition = Seq(&quot;ab&quot;, &quot;bc&quot;, &quot;cd&quot;).
  foldLeft(lit(0))((cnt, e) =&gt; sumFriends(cnt, col(e)(&quot;relationship&quot;)))
//  (c) Apply filter to DataFrame.
val chainWith2Friends2 = chain4.where(condition &gt;= 2)
display(chainWith2Friends2)
</code></pre>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-scala">chain4
</code></pre>
<div class="output execute_result plain_result" execution_count="1">
<pre><code>res22: org.apache.spark.sql.DataFrame = [a: struct&lt;id: string, name: string ... 1 more field&gt;, ab: struct&lt;src: string, dst: string ... 1 more field&gt; ... 5 more fields]
</code></pre>
</div>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-scala">chain4.printSchema
</code></pre>
<div class="output execute_result plain_result" execution_count="1">
<pre><code>root
 |-- a: struct (nullable = false)
 |    |-- id: string (nullable = true)
 |    |-- name: string (nullable = true)
 |    |-- age: integer (nullable = false)
 |-- ab: struct (nullable = false)
 |    |-- src: string (nullable = true)
 |    |-- dst: string (nullable = true)
 |    |-- relationship: string (nullable = true)
 |-- b: struct (nullable = false)
 |    |-- id: string (nullable = true)
 |    |-- name: string (nullable = true)
 |    |-- age: integer (nullable = false)
 |-- bc: struct (nullable = false)
 |    |-- src: string (nullable = true)
 |    |-- dst: string (nullable = true)
 |    |-- relationship: string (nullable = true)
 |-- c: struct (nullable = false)
 |    |-- id: string (nullable = true)
 |    |-- name: string (nullable = true)
 |    |-- age: integer (nullable = false)
 |-- cd: struct (nullable = false)
 |    |-- src: string (nullable = true)
 |    |-- dst: string (nullable = true)
 |    |-- relationship: string (nullable = true)
 |-- d: struct (nullable = false)
 |    |-- id: string (nullable = true)
 |    |-- name: string (nullable = true)
 |    |-- age: integer (nullable = false)
</code></pre>
</div>
</div>
<div class="cell markdown">
<h3 id="an-idea----a-diatribe-into-an-ai-security-product"><a class="header" href="#an-idea----a-diatribe-into-an-ai-security-product">An idea -- a diatribe into an AI security product.</a></h3>
<p>Can you think of a way to use stateful queries in social media networks to find perpetrators of hate-speech online who are possibly worthy of an investigation by domain experts, say in the intelligence or security domain, for potential prosecution on charges of having incited another person to cause physical violence... This is a real problem today as Swedish law effectively prohibits certain forms of online hate-speech.</p>
<p>An idea for a product that can be used by Swedish security agencies?</p>
<p>See <a href="https://n%C3%A4thatsgranskaren.se/">https://näthatsgranskaren.se/</a> for details of a non-profit in Sweden doing such operaitons mostly manually as of early 2020.</p>
</div>
<div class="cell markdown">
<h3 id="subgraphs"><a class="header" href="#subgraphs">Subgraphs</a></h3>
<p>Subgraphs are built by filtering a subset of edges and vertices. For example, the following subgraph only contains people who are friends and who are more than 30 years old.</p>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-scala">// Select subgraph of users older than 30, and edges of type &quot;friend&quot;
val v2 = g.vertices.filter(&quot;age &gt; 30&quot;)
val e2 = g.edges.filter(&quot;relationship = 'friend'&quot;)
val g2 = GraphFrame(v2, e2)
</code></pre>
<div class="output execute_result plain_result" execution_count="1">
<pre><code>v2: org.apache.spark.sql.Dataset[org.apache.spark.sql.Row] = [id: string, name: string ... 1 more field]
e2: org.apache.spark.sql.Dataset[org.apache.spark.sql.Row] = [src: string, dst: string ... 1 more field]
g2: org.graphframes.GraphFrame = GraphFrame(v:[id: string, name: string ... 1 more field], e:[src: string, dst: string ... 1 more field])
</code></pre>
</div>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-scala">display(g2.vertices)
</code></pre>
<div class="output execute_result tabular_result" execution_count="1">
<table>
<thead>
<tr class="header">
<th>id</th>
<th>name</th>
<th>age</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>a</td>
<td>Alice</td>
<td>34.0</td>
</tr>
<tr class="even">
<td>b</td>
<td>Bob</td>
<td>36.0</td>
</tr>
<tr class="odd">
<td>e</td>
<td>Esther</td>
<td>32.0</td>
</tr>
<tr class="even">
<td>f</td>
<td>Fanny</td>
<td>36.0</td>
</tr>
<tr class="odd">
<td>g</td>
<td>Gabby</td>
<td>60.0</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-scala">display(g2.edges)
</code></pre>
<div class="output execute_result tabular_result" execution_count="1">
<table>
<thead>
<tr class="header">
<th>src</th>
<th>dst</th>
<th>relationship</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>a</td>
<td>b</td>
<td>friend</td>
</tr>
<tr class="even">
<td>e</td>
<td>d</td>
<td>friend</td>
</tr>
<tr class="odd">
<td>d</td>
<td>a</td>
<td>friend</td>
</tr>
<tr class="even">
<td>a</td>
<td>e</td>
<td>friend</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="cell code" execution_count="1" scrolled="auto">
<pre><code class="language-scala">d3.graphs.force( // let us see g2 now in one cell
  height = 500,
  width = 500,
  clicks = g2.edges.select($&quot;src&quot;, $&quot;dst&quot;.as(&quot;dest&quot;), lit(1L).as(&quot;count&quot;)).as[d3.Edge])
</code></pre>
<div class="output execute_result html_result" execution_count="1">
<style>

.node_circle {
  stroke: #777;
  stroke-width: 1.3px;
}

.node_label {
  pointer-events: none;
}

.link {
  stroke: #777;
  stroke-opacity: .2;
}

.node_count {
  stroke: #777;
  stroke-width: 1.0px;
  fill: #999;
}

text.legend {
  font-family: Verdana;
  font-size: 13px;
  fill: #000;
}

.node text {
  font-family: "Helvetica Neue","Helvetica","Arial",sans-serif;
  font-size: 17px;
  font-weight: 200;
}

</style>
<div id="clicks-graph">
<script src="//d3js.org/d3.v3.min.js"></script>
<script>
<p>var graph = {&quot;nodes&quot;:[{&quot;name&quot;:&quot;a&quot;},{&quot;name&quot;:&quot;e&quot;},{&quot;name&quot;:&quot;d&quot;},{&quot;name&quot;:&quot;b&quot;}],&quot;links&quot;:[{&quot;source&quot;:0,&quot;target&quot;:3,&quot;value&quot;:1},{&quot;source&quot;:1,&quot;target&quot;:2,&quot;value&quot;:1},{&quot;source&quot;:2,&quot;target&quot;:0,&quot;value&quot;:1},{&quot;source&quot;:0,&quot;target&quot;:1,&quot;value&quot;:1}]};</p>
<p>var width = 500,
height = 500;</p>
<p>var color = d3.scale.category20();</p>
<p>var force = d3.layout.force()
.charge(-700)
.linkDistance(180)
.size([width, height]);</p>
<p>var svg = d3.select(&quot;#clicks-graph&quot;).append(&quot;svg&quot;)
.attr(&quot;width&quot;, width)
.attr(&quot;height&quot;, height);</p>
<p>force
.nodes(graph.nodes)
.links(graph.links)
.start();</p>
<p>var link = svg.selectAll(&quot;.link&quot;)
.data(graph.links)
.enter().append(&quot;line&quot;)
.attr(&quot;class&quot;, &quot;link&quot;)
.style(&quot;stroke-width&quot;, function(d) { return Math.sqrt(d.value); });</p>
<p>var node = svg.selectAll(&quot;.node&quot;)
.data(graph.nodes)
.enter().append(&quot;g&quot;)
.attr(&quot;class&quot;, &quot;node&quot;)
.call(force.drag);</p>
<p>node.append(&quot;circle&quot;)
.attr(&quot;r&quot;, 10)
.style(&quot;fill&quot;, function (d) {
if (d.name.startsWith(&quot;other&quot;)) { return color(1); } else { return color(2); };
})</p>
<p>node.append(&quot;text&quot;)
.attr(&quot;dx&quot;, 10)
.attr(&quot;dy&quot;, &quot;.35em&quot;)
.text(function(d) { return d.name });</p>
<p>//Now we are giving the SVGs co-ordinates - the force layout is generating the co-ordinates which this code is using to update the attributes of the SVG elements
force.on(&quot;tick&quot;, function () {
link.attr(&quot;x1&quot;, function (d) {
return d.source.x;
})
.attr(&quot;y1&quot;, function (d) {
return d.source.y;
})
.attr(&quot;x2&quot;, function (d) {
return d.target.x;
})
.attr(&quot;y2&quot;, function (d) {
return d.target.y;
});
d3.selectAll(&quot;circle&quot;).attr(&quot;cx&quot;, function (d) {
return d.x;
})
.attr(&quot;cy&quot;, function (d) {
return d.y;
});
d3.selectAll(&quot;text&quot;).attr(&quot;x&quot;, function (d) {
return d.x;
})
.attr(&quot;y&quot;, function (d) {
return d.y;
});
});
</script></p>
</div>
</div>
</div>
<div class="cell markdown">
<p><strong>Complex triplet filters</strong></p>
<p>The following example shows how to select a subgraph based upon triplet filters which operate on:</p>
<ul>
<li>an edge and</li>
<li>its src and</li>
<li>dst vertices.</li>
</ul>
<p>This example could be extended to go beyond triplets by using more complex motifs.</p>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-scala">// Select subgraph based on edges &quot;e&quot; of type &quot;follow&quot;
// pointing from a younger user &quot;a&quot; to an older user &quot;b&quot;.
val paths = g.find(&quot;(a)-[e]-&gt;(b)&quot;)
  .filter(&quot;e.relationship = 'follow'&quot;)
  .filter(&quot;a.age &lt; b.age&quot;)
// &quot;paths&quot; contains vertex info. Extract the edges.
val e2 = paths.select(&quot;e.src&quot;, &quot;e.dst&quot;, &quot;e.relationship&quot;)
// In Spark 1.5+, the user may simplify this call:
//  val e2 = paths.select(&quot;e.*&quot;)

// Construct the subgraph
val g2 = GraphFrame(g.vertices, e2)
</code></pre>
<div class="output execute_result plain_result" execution_count="1">
<pre><code>paths: org.apache.spark.sql.Dataset[org.apache.spark.sql.Row] = [a: struct&lt;id: string, name: string ... 1 more field&gt;, e: struct&lt;src: string, dst: string ... 1 more field&gt; ... 1 more field]
e2: org.apache.spark.sql.DataFrame = [src: string, dst: string ... 1 more field]
g2: org.graphframes.GraphFrame = GraphFrame(v:[id: string, name: string ... 1 more field], e:[src: string, dst: string ... 1 more field])
</code></pre>
</div>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-scala">display(g2.vertices)
</code></pre>
<div class="output execute_result tabular_result" execution_count="1">
<table>
<thead>
<tr class="header">
<th>id</th>
<th>name</th>
<th>age</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>a</td>
<td>Alice</td>
<td>34.0</td>
</tr>
<tr class="even">
<td>b</td>
<td>Bob</td>
<td>36.0</td>
</tr>
<tr class="odd">
<td>c</td>
<td>Charlie</td>
<td>30.0</td>
</tr>
<tr class="even">
<td>d</td>
<td>David</td>
<td>29.0</td>
</tr>
<tr class="odd">
<td>e</td>
<td>Esther</td>
<td>32.0</td>
</tr>
<tr class="even">
<td>f</td>
<td>Fanny</td>
<td>36.0</td>
</tr>
<tr class="odd">
<td>g</td>
<td>Gabby</td>
<td>60.0</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-scala">display(g2.edges)
</code></pre>
<div class="output execute_result tabular_result" execution_count="1">
<table>
<thead>
<tr class="header">
<th>src</th>
<th>dst</th>
<th>relationship</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>c</td>
<td>b</td>
<td>follow</td>
</tr>
<tr class="even">
<td>e</td>
<td>f</td>
<td>follow</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="cell markdown">
<h2 id="standard-graph-algorithms-in-graphx-conveniently-via-graphframes"><a class="header" href="#standard-graph-algorithms-in-graphx-conveniently-via-graphframes">Standard graph algorithms in GraphX conveniently via GraphFrames</a></h2>
<p>GraphFrames comes with a number of standard graph algorithms built in:</p>
<ul>
<li>Breadth-first search (BFS)</li>
<li>Connected components</li>
<li>Strongly connected components</li>
<li>Label Propagation Algorithm (LPA)</li>
<li>PageRank</li>
<li>Shortest paths</li>
<li>Triangle count</li>
</ul>
</div>
<div class="cell markdown">
<h3 id="breadth-first-search-bfs"><a class="header" href="#breadth-first-search-bfs">Breadth-first search (BFS)</a></h3>
</div>
<div class="cell markdown">
<p>Read</p>
<p>https://graphframes.github.io/graphframes/docs/_site/user-guide.html</p>
<ul>
<li><a href="https://graphframes.github.io/graphframes/docs/_site/user-guide.html#breadth-first-search-bfs">graphframes user-guide breadth-first-search-bfs</a>.</li>
</ul>
</div>
<div class="cell code" execution_count="1" scrolled="auto">
<div class="output execute_result html_result" execution_count="1">
<iframe 
 src="https://en.wikipedia.org/wiki/Breadth-first_search"
 width="95%" height="500"
 sandbox>
  <p>
    <a href="http://spark.apache.org/docs/latest/index.html">
      Fallback link for browsers that, unlikely, don't support frames
    </a>
  </p>
</iframe>
</div>
</div>
<div class="cell markdown">
<p>Search from &quot;Esther&quot; for users of age &lt; 32.</p>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-scala">// Search from &quot;Esther&quot; for users of age &lt;= 32.
val paths: DataFrame = g.bfs.fromExpr(&quot;name = 'Esther'&quot;).toExpr(&quot;age &lt; 32&quot;).run()
display(paths)
</code></pre>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-scala">val paths: DataFrame = g.bfs.fromExpr(&quot;name = 'Esther' OR name = 'Bob'&quot;).toExpr(&quot;age &lt; 32&quot;).run()
display(paths)
</code></pre>
</div>
<div class="cell markdown">
<p>The search may also be limited by edge filters and maximum path lengths.</p>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-scala">val filteredPaths = g.bfs.fromExpr(&quot;name = 'Esther'&quot;).toExpr(&quot;age &lt; 32&quot;)
  .edgeFilter(&quot;relationship != 'friend'&quot;)
  .maxPathLength(3)
  .run()
display(filteredPaths)
</code></pre>
</div>
<div class="cell markdown">
<h3 id="connected-components"><a class="header" href="#connected-components">Connected components</a></h3>
<p>Compute the connected component membership of each vertex and return a graph with each vertex assigned a component ID.</p>
<p>READ <a href="https://graphframes.github.io/graphframes/docs/_site/user-guide.html#connected-components">https://graphframes.github.io/graphframes/docs/_site/user-guide.html#connected-components</a>.</p>
</div>
<div class="cell code" execution_count="1" scrolled="auto">
<div class="output execute_result html_result" execution_count="1">
<iframe 
 src="https://en.wikipedia.org/wiki/Connected_component_(graph_theory)"
 width="95%" height="500"
 sandbox>
  <p>
    <a href="http://spark.apache.org/docs/latest/index.html">
      Fallback link for browsers that, unlikely, don't support frames
    </a>
  </p>
</iframe>
</div>
</div>
<div class="cell markdown">
<p>From <a href="https://graphframes.github.io/graphframes/docs/_site/user-guide.html#connected-components">https://graphframes.github.io/graphframes/docs/_site/user-guide.html#connected-components</a>:-</p>
<p>NOTE: With GraphFrames 0.3.0 and later releases, the default Connected Components algorithm requires setting a Spark checkpoint directory. Users can revert to the old algorithm using <code>.setAlgorithm(&quot;graphx&quot;)</code>.</p>
<p>Recall the following quote from <a href="https://learning.oreilly.com/library/view/high-performance-spark/9781491943199/ch05.html">Chapter 5 on <em>Effective Transformations</em> of the <em>High Performance Spark</em> Book</a> why one needs to check-point to keep the RDD lineage DAGs from growing too large.</p>
<blockquote>
<p><strong>Types of Reuse: Cache, Persist, Checkpoint, Shuffle Files</strong> If you decide that you need to reuse your RDD, Spark provides a multitude of options for how to store the RDD. Thus it is important to understand when to use the various types of persistence.There are three primary operations that you can use to store your RDD: cache, persist, and checkpoint. In general, caching (equivalent to persisting with the in-memory storage) and persisting are most useful to avoid recomputation during one Spark job or to break RDDs with long lineages, since they keep an RDD on the executors during a Spark job. <strong>Checkpointing is most useful to prevent failures and a high cost of recomputation by saving intermediate results. Like persisting, checkpointing helps avoid computation, thus minimizing the cost of failure, and avoids recomputation by breaking the lineage graph.</strong></p>
</blockquote>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-scala">sc.setCheckpointDir(&quot;/_checkpoint&quot;) // just a directory in distributed file system
val result = g.connectedComponents.run() 
display(result)
</code></pre>
<div class="output execute_result tabular_result" execution_count="1">
<table>
<thead>
<tr class="header">
<th>id</th>
<th>name</th>
<th>age</th>
<th>component</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>a</td>
<td>Alice</td>
<td>34.0</td>
<td>4.12316860416e11</td>
</tr>
<tr class="even">
<td>b</td>
<td>Bob</td>
<td>36.0</td>
<td>4.12316860416e11</td>
</tr>
<tr class="odd">
<td>c</td>
<td>Charlie</td>
<td>30.0</td>
<td>4.12316860416e11</td>
</tr>
<tr class="even">
<td>d</td>
<td>David</td>
<td>29.0</td>
<td>4.12316860416e11</td>
</tr>
<tr class="odd">
<td>e</td>
<td>Esther</td>
<td>32.0</td>
<td>4.12316860416e11</td>
</tr>
<tr class="even">
<td>f</td>
<td>Fanny</td>
<td>36.0</td>
<td>4.12316860416e11</td>
</tr>
<tr class="odd">
<td>g</td>
<td>Gabby</td>
<td>60.0</td>
<td>1.46028888064e11</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="cell markdown">
<p>Fun Exercise: Try to modify the d3.graph function to allow a visualisation of a given Sequence of <code>component</code> ids in the above <code>result</code>.</p>
</div>
<div class="cell markdown">
<h2 id="strongly-connected-components"><a class="header" href="#strongly-connected-components">Strongly connected components</a></h2>
<p>Compute the strongly connected component (SCC) of each vertex and return a graph with each vertex assigned to the SCC containing that vertex.</p>
<p>READ <a href="https://graphframes.github.io/graphframes/docs/_site/user-guide.html#strongly-connected-components">https://graphframes.github.io/graphframes/docs/_site/user-guide.html#strongly-connected-components</a>.</p>
</div>
<div class="cell code" execution_count="1" scrolled="auto">
<div class="output execute_result html_result" execution_count="1">
<iframe 
 src="https://en.wikipedia.org/wiki/Strongly_connected_component"
 width="95%" height="500"
 sandbox>
  <p>
    <a href="http://spark.apache.org/docs/latest/index.html">
      Fallback link for browsers that, unlikely, don't support frames
    </a>
  </p>
</iframe>
</div>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-scala">val result = g.stronglyConnectedComponents.maxIter(10).run()
display(result.orderBy(&quot;component&quot;))
</code></pre>
<div class="output execute_result tabular_result" execution_count="1">
<table>
<thead>
<tr class="header">
<th>id</th>
<th>name</th>
<th>age</th>
<th>component</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>g</td>
<td>Gabby</td>
<td>60.0</td>
<td>1.46028888064e11</td>
</tr>
<tr class="even">
<td>f</td>
<td>Fanny</td>
<td>36.0</td>
<td>4.12316860416e11</td>
</tr>
<tr class="odd">
<td>a</td>
<td>Alice</td>
<td>34.0</td>
<td>6.70014898176e11</td>
</tr>
<tr class="even">
<td>e</td>
<td>Esther</td>
<td>32.0</td>
<td>6.70014898176e11</td>
</tr>
<tr class="odd">
<td>d</td>
<td>David</td>
<td>29.0</td>
<td>6.70014898176e11</td>
</tr>
<tr class="even">
<td>b</td>
<td>Bob</td>
<td>36.0</td>
<td>1.047972020224e12</td>
</tr>
<tr class="odd">
<td>c</td>
<td>Charlie</td>
<td>30.0</td>
<td>1.047972020224e12</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="cell markdown">
<h2 id="label-propagation"><a class="header" href="#label-propagation">Label propagation</a></h2>
<p>Run static Label Propagation Algorithm for detecting communities in networks.</p>
<p>Each node in the network is initially assigned to its own community. At every superstep, nodes send their community affiliation to all neighbors and update their state to the mode community affiliation of incoming messages.</p>
<p>LPA is a standard community detection algorithm for graphs. It is very inexpensive computationally, although</p>
<ul>
<li>(1) convergence is not guaranteed and</li>
<li>(2) one can end up with trivial solutions (all nodes are identified into a single community).</li>
</ul>
<p>READ: <a href="https://graphframes.github.io/graphframes/docs/_site/user-guide.html#label-propagation-algorithm-lpa">https://graphframes.github.io/graphframes/docs/_site/user-guide.html#label-propagation-algorithm-lpa</a>.</p>
</div>
<div class="cell code" execution_count="1" scrolled="auto">
<div class="output execute_result html_result" execution_count="1">
<iframe 
 src="https://en.wikipedia.org/wiki/Label_Propagation_Algorithm"
 width="95%" height="500"
 sandbox>
  <p>
    <a href="http://spark.apache.org/docs/latest/index.html">
      Fallback link for browsers that, unlikely, don't support frames
    </a>
  </p>
</iframe>
</div>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-scala">val result = g.labelPropagation.maxIter(5).run()
display(result.orderBy(&quot;label&quot;))
</code></pre>
<div class="output execute_result tabular_result" execution_count="1">
<table>
<thead>
<tr class="header">
<th>id</th>
<th>name</th>
<th>age</th>
<th>label</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>g</td>
<td>Gabby</td>
<td>60.0</td>
<td>1.46028888064e11</td>
</tr>
<tr class="even">
<td>b</td>
<td>Bob</td>
<td>36.0</td>
<td>1.047972020224e12</td>
</tr>
<tr class="odd">
<td>e</td>
<td>Esther</td>
<td>32.0</td>
<td>1.382979469312e12</td>
</tr>
<tr class="even">
<td>a</td>
<td>Alice</td>
<td>34.0</td>
<td>1.382979469312e12</td>
</tr>
<tr class="odd">
<td>c</td>
<td>Charlie</td>
<td>30.0</td>
<td>1.382979469312e12</td>
</tr>
<tr class="even">
<td>f</td>
<td>Fanny</td>
<td>36.0</td>
<td>1.46028888064e12</td>
</tr>
<tr class="odd">
<td>d</td>
<td>David</td>
<td>29.0</td>
<td>1.46028888064e12</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="cell markdown">
<h2 id="pagerank"><a class="header" href="#pagerank">PageRank</a></h2>
<p>Identify important vertices in a graph based on connections.</p>
<p>READ: <a href="https://graphframes.github.io/graphframes/docs/_site/user-guide.html#pagerank">https://graphframes.github.io/graphframes/docs/_site/user-guide.html#pagerank</a>.</p>
</div>
<div class="cell code" execution_count="1" scrolled="auto">
<div class="output execute_result html_result" execution_count="1">
<iframe 
 src="https://en.wikipedia.org/wiki/PageRank"
 width="95%" height="500"
 sandbox>
  <p>
    <a href="http://spark.apache.org/docs/latest/index.html">
      Fallback link for browsers that, unlikely, don't support frames
    </a>
  </p>
</iframe>
</div>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-scala">// Run PageRank until convergence to tolerance &quot;tol&quot;.
val results = g.pageRank.resetProbability(0.15).tol(0.01).run()
display(results.vertices)
</code></pre>
<div class="output execute_result tabular_result" execution_count="1">
<table>
<thead>
<tr class="header">
<th>id</th>
<th>name</th>
<th>age</th>
<th>pagerank</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>b</td>
<td>Bob</td>
<td>36.0</td>
<td>2.655507832863289</td>
</tr>
<tr class="even">
<td>e</td>
<td>Esther</td>
<td>32.0</td>
<td>0.37085233187676075</td>
</tr>
<tr class="odd">
<td>a</td>
<td>Alice</td>
<td>34.0</td>
<td>0.44910633706538744</td>
</tr>
<tr class="even">
<td>f</td>
<td>Fanny</td>
<td>36.0</td>
<td>0.3283606792049851</td>
</tr>
<tr class="odd">
<td>g</td>
<td>Gabby</td>
<td>60.0</td>
<td>0.1799821386239711</td>
</tr>
<tr class="even">
<td>d</td>
<td>David</td>
<td>29.0</td>
<td>0.3283606792049851</td>
</tr>
<tr class="odd">
<td>c</td>
<td>Charlie</td>
<td>30.0</td>
<td>2.6878300011606218</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-scala">display(results.edges)
</code></pre>
<div class="output execute_result tabular_result" execution_count="1">
<table>
<thead>
<tr class="header">
<th>src</th>
<th>dst</th>
<th>relationship</th>
<th>weight</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>f</td>
<td>c</td>
<td>follow</td>
<td>1.0</td>
</tr>
<tr class="even">
<td>e</td>
<td>f</td>
<td>follow</td>
<td>0.5</td>
</tr>
<tr class="odd">
<td>e</td>
<td>d</td>
<td>friend</td>
<td>0.5</td>
</tr>
<tr class="even">
<td>d</td>
<td>a</td>
<td>friend</td>
<td>1.0</td>
</tr>
<tr class="odd">
<td>c</td>
<td>b</td>
<td>follow</td>
<td>1.0</td>
</tr>
<tr class="even">
<td>b</td>
<td>c</td>
<td>follow</td>
<td>1.0</td>
</tr>
<tr class="odd">
<td>a</td>
<td>e</td>
<td>friend</td>
<td>0.5</td>
</tr>
<tr class="even">
<td>a</td>
<td>b</td>
<td>friend</td>
<td>0.5</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-scala">// Run PageRank for a fixed number of iterations.
val results2 = g.pageRank.resetProbability(0.15).maxIter(10).run()
display(results2.vertices)
</code></pre>
<div class="output execute_result tabular_result" execution_count="1">
<table>
<thead>
<tr class="header">
<th>id</th>
<th>name</th>
<th>age</th>
<th>pagerank</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>b</td>
<td>Bob</td>
<td>36.0</td>
<td>2.7025217677349773</td>
</tr>
<tr class="even">
<td>e</td>
<td>Esther</td>
<td>32.0</td>
<td>0.3613490987992571</td>
</tr>
<tr class="odd">
<td>a</td>
<td>Alice</td>
<td>34.0</td>
<td>0.4485115093698443</td>
</tr>
<tr class="even">
<td>f</td>
<td>Fanny</td>
<td>36.0</td>
<td>0.32504910549694244</td>
</tr>
<tr class="odd">
<td>g</td>
<td>Gabby</td>
<td>60.0</td>
<td>0.17073170731707318</td>
</tr>
<tr class="even">
<td>d</td>
<td>David</td>
<td>29.0</td>
<td>0.32504910549694244</td>
</tr>
<tr class="odd">
<td>c</td>
<td>Charlie</td>
<td>30.0</td>
<td>2.6667877057849627</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-scala">// Run PageRank personalized for vertex &quot;a&quot;
val results3 = g.pageRank.resetProbability(0.15).maxIter(10).sourceId(&quot;a&quot;).run()
display(results3.vertices)
</code></pre>
<div class="output execute_result tabular_result" execution_count="1">
<table>
<thead>
<tr class="header">
<th>id</th>
<th>name</th>
<th>age</th>
<th>pagerank</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>b</td>
<td>Bob</td>
<td>36.0</td>
<td>0.3366143039702568</td>
</tr>
<tr class="even">
<td>e</td>
<td>Esther</td>
<td>32.0</td>
<td>7.657840357273027e-2</td>
</tr>
<tr class="odd">
<td>a</td>
<td>Alice</td>
<td>34.0</td>
<td>0.17710831642683564</td>
</tr>
<tr class="even">
<td>f</td>
<td>Fanny</td>
<td>36.0</td>
<td>3.189213697274781e-2</td>
</tr>
<tr class="odd">
<td>g</td>
<td>Gabby</td>
<td>60.0</td>
<td>0.0</td>
</tr>
<tr class="even">
<td>d</td>
<td>David</td>
<td>29.0</td>
<td>3.189213697274781e-2</td>
</tr>
<tr class="odd">
<td>c</td>
<td>Charlie</td>
<td>30.0</td>
<td>0.3459147020846817</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="cell markdown">
<h2 id="shortest-paths"><a class="header" href="#shortest-paths">Shortest paths</a></h2>
<p>Computes shortest paths to the given set of landmark vertices, where landmarks are specified by vertex ID.</p>
<p>READ <a href="https://graphframes.github.io/graphframes/docs/_site/user-guide.html#shortest-paths">https://graphframes.github.io/graphframes/docs/_site/user-guide.html#shortest-paths</a>.</p>
</div>
<div class="cell code" execution_count="1" scrolled="auto">
<div class="output execute_result html_result" execution_count="1">
<iframe 
 src="https://en.wikipedia.org/wiki/Shortest_path_problem"
 width="95%" height="500"
 sandbox>
  <p>
    <a href="http://spark.apache.org/docs/latest/index.html">
      Fallback link for browsers that, unlikely, don't support frames
    </a>
  </p>
</iframe>
</div>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-scala">val paths = g.shortestPaths.landmarks(Seq(&quot;a&quot;, &quot;d&quot;)).run()
display(paths)
</code></pre>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-scala">g.edges.show()
</code></pre>
<div class="output execute_result plain_result" execution_count="1">
<pre><code>+---+---+------------+
|src|dst|relationship|
+---+---+------------+
|  a|  b|      friend|
|  b|  c|      follow|
|  c|  b|      follow|
|  f|  c|      follow|
|  e|  f|      follow|
|  e|  d|      friend|
|  d|  a|      friend|
|  a|  e|      friend|
+---+---+------------+
</code></pre>
</div>
</div>
<div class="cell markdown">
<h3 id="triangle-count"><a class="header" href="#triangle-count">Triangle count</a></h3>
<p>Computes the number of triangles passing through each vertex.</p>
</div>
<div class="cell markdown">
<p>See <a href="https://graphframes.github.io/graphframes/docs/_site/user-guide.html#triangle-count">https://graphframes.github.io/graphframes/docs/_site/user-guide.html#triangle-count</a></p>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-scala">val results = g.triangleCount.run()
display(results)
</code></pre>
<div class="output execute_result tabular_result" execution_count="1">
<table>
<thead>
<tr class="header">
<th>count</th>
<th>id</th>
<th>name</th>
<th>age</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1.0</td>
<td>a</td>
<td>Alice</td>
<td>34.0</td>
</tr>
<tr class="even">
<td>0.0</td>
<td>b</td>
<td>Bob</td>
<td>36.0</td>
</tr>
<tr class="odd">
<td>0.0</td>
<td>c</td>
<td>Charlie</td>
<td>30.0</td>
</tr>
<tr class="even">
<td>1.0</td>
<td>d</td>
<td>David</td>
<td>29.0</td>
</tr>
<tr class="odd">
<td>1.0</td>
<td>e</td>
<td>Esther</td>
<td>32.0</td>
</tr>
<tr class="even">
<td>0.0</td>
<td>f</td>
<td>Fanny</td>
<td>36.0</td>
</tr>
<tr class="odd">
<td>0.0</td>
<td>g</td>
<td>Gabby</td>
<td>60.0</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="cell markdown">
<h2 id="youtry"><a class="header" href="#youtry">YouTry</a></h2>
<p>Read about <a href="https://graphframes.github.io/graphframes/docs/_site/user-guide.html#message-passing-via-aggregatemessages">https://graphframes.github.io/graphframes/docs/_site/user-guide.html#message-passing-via-aggregatemessages</a></p>
<p>and undestand how the below code snippet shows how to use aggregateMessages to compute the sum of the ages of adjacent users.</p>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-scala">import org.graphframes.{examples,GraphFrame}
import org.graphframes.lib.AggregateMessages
val g: GraphFrame = examples.Graphs.friends  // get example graph

// We will use AggregateMessages utilities later, so name it &quot;AM&quot; for short.
val AM = AggregateMessages

// For each user, sum the ages of the adjacent users.
val msgToSrc = AM.dst(&quot;age&quot;)
val msgToDst = AM.src(&quot;age&quot;)
val agg = { g.aggregateMessages
  .sendToSrc(msgToSrc)  // send destination user's age to source
  .sendToDst(msgToDst)  // send source user's age to destination
  .agg(sum(AM.msg).as(&quot;summedAges&quot;)) } // sum up ages, stored in AM.msg column
agg.show()
</code></pre>
<div class="output execute_result plain_result" execution_count="1">
<pre><code>+---+----------+
| id|summedAges|
+---+----------+
|  a|        97|
|  c|       108|
|  e|        99|
|  d|        66|
|  b|        94|
|  f|        62|
+---+----------+

import org.graphframes.{examples, GraphFrame}
import org.graphframes.lib.AggregateMessages
g: org.graphframes.GraphFrame = GraphFrame(v:[id: string, name: string ... 1 more field], e:[src: string, dst: string ... 1 more field])
AM: org.graphframes.lib.AggregateMessages.type = org.graphframes.lib.AggregateMessages$@706833c8
msgToSrc: org.apache.spark.sql.Column = dst[age]
msgToDst: org.apache.spark.sql.Column = src[age]
agg: org.apache.spark.sql.DataFrame = [id: string, summedAges: bigint]
</code></pre>
</div>
</div>
<div class="cell markdown">
<p>There is a lot more that can be done with aggregate messaging - let's get into belief propogation algorithm for a more complex example!</p>
<p>Belief propogation is a powerful computational framework for Graphical Models.</p>
<ul>
<li>let's dive here:
<ul>
<li><a href="https://github.com/graphframes/graphframes/blob/master/src/main/scala/org/graphframes/examples/BeliefPropagation.scala">https://github.com/graphframes/graphframes/blob/master/src/main/scala/org/graphframes/examples/BeliefPropagation.scala</a></li>
</ul>
</li>
</ul>
<p>as</p>
<blockquote>
<p>This provides a template for building customized BP algorithms for different types of graphical models.</p>
</blockquote>
</div>
<div class="cell code" execution_count="1" scrolled="auto">
<div class="output execute_result html_result" execution_count="1">
<iframe 
 src="https://en.wikipedia.org/wiki/Belief_propagation"
 width="95%" height="500"
 sandbox>
  <p>
    <a href="http://spark.apache.org/docs/latest/index.html">
      Fallback link for browsers that, unlikely, don't support frames
    </a>
  </p>
</iframe>
</div>
</div>
<div class="cell code" execution_count="1" scrolled="auto">
<div class="output execute_result html_result" execution_count="1">
<iframe 
 src="https://en.wikipedia.org/wiki/Ising_model"
 width="95%" height="500"
 sandbox>
  <p>
    <a href="http://spark.apache.org/docs/latest/index.html">
      Fallback link for browsers that, unlikely, don't support frames
    </a>
  </p>
</iframe>
</div>
</div>
<div class="cell markdown">
<h2 id="project-idea"><a class="header" href="#project-idea">Project Idea</a></h2>
<p>Understand <em>parallel belief propagation using colored fields</em> in the Scala code linked above and also pasted below in one cell (for you to modify if you want to do it in a databricks or jupyter or zeppelin notebook) unless you want to fork and extend the github repo directly with your own example.</p>
<p>Then use it with necessary adaptations to be able to model your favorite interacting particle system. Don't just redo the Ising model done there!</p>
<p>This can be used to gain intuition for various real-world scenarios, including the mathematics in your head:</p>
<ul>
<li>Make a graph for contact network of a set of hosts</li>
<li>A simple model of COVID spreading in an SI or SIS or SIR or other epidemic models
<ul>
<li>this can be abstract and simply show your skills in programming, say create a random network</li>
<li>or be more explicit with some assumptions about the contact process (population sampled, in one or two cities, with some assumptions on contacts during transportation, school, work, etc)</li>
<li>show that you have a fully scalable simulation model that can theoretically scale to billions of hosts</li>
</ul>
</li>
</ul>
<p>The project does not have to be a recommendation to Swedish authorities! Just a start in the right direction, for instance.</p>
<p>Some readings that can help here include the following and references therein:</p>
<ul>
<li>The Transmission Process: A Combinatorial Stochastic Process for the Evolution of Transmission Trees over Networks, Raazesh Sainudiin and David Welch, Journal of Theoretical Biology, Volume 410, Pages 137–170, <a href="http://dx.doi.org/10.1016/j.jtbi.2016.07.038">10.1016/j.jtbi.2016.07.038</a>, 2016.</li>
</ul>
<h2 id="other-project-ideas"><a class="header" href="#other-project-ideas">Other Project Ideas</a></h2>
<ul>
<li>try to do a scalable inference algorithm for one of the graphical models that you already know...</li>
<li>make a large simulaiton of your favourite <em>Finite Markov Information Exchange (FMIE)</em> process defined by Aldous (see reference in the above linked paper)</li>
<li>anything else that fancies you or your research orientation/interests and can benefit from adapting the template for the <em>parallel belief propagation</em> algorithm here.</li>
</ul>
</div>
<div class="cell markdown">
<p>If you want to do this project in databricks (or other) notebook then start by modifying the following code from the example and making it run... Then adapt... start in small steps... make a team with fellow students with complementary skills...</p>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-scala">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.graphframes.examples

import org.apache.spark.{SparkConf, SparkContext}
import org.apache.spark.graphx.{Graph, VertexRDD, Edge =&gt; GXEdge}
import org.apache.spark.sql.{Column, Row, SparkSession, SQLContext}
import org.apache.spark.sql.functions.{col, lit, sum, udf, when}

import org.graphframes.GraphFrame
import org.graphframes.examples.Graphs.gridIsingModel
import org.graphframes.lib.AggregateMessages


/**
 * Example code for Belief Propagation (BP)
 *
 * This provides a template for building customized BP algorithms for different types of
 * graphical models.
 *
 * This example:
 *  - Ising model on a grid
 *  - Parallel Belief Propagation using colored fields
 *
 * Ising models are probabilistic graphical models over binary variables x,,i,,.
 * Each binary variable x,,i,, corresponds to one vertex, and it may take values -1 or +1.
 * The probability distribution P(X) (over all x,,i,,) is parameterized by vertex factors a,,i,,
 * and edge factors b,,ij,,:
 * {{{
 *  P(X) = (1/Z) * exp[ \sum_i a_i x_i + \sum_{ij} b_{ij} x_i x_j ]
 * }}}
 * where Z is the normalization constant (partition function).
 * See [[https://en.wikipedia.org/wiki/Ising_model Wikipedia]] for more information on Ising models.
 *
 * Belief Propagation (BP) provides marginal probabilities of the values of the variables x,,i,,,
 * i.e., P(x,,i,,) for each i.  This allows a user to understand likely values of variables.
 * See [[https://en.wikipedia.org/wiki/Belief_propagation Wikipedia]] for more information on BP.
 *
 * We use a batch synchronous BP algorithm, where batches of vertices are updated synchronously.
 * We follow the mean field update algorithm in Slide 13 of the
 * [[http://www.eecs.berkeley.edu/~wainwrig/Talks/A_GraphModel_Tutorial  talk slides]] from:
 *  Wainwright. &quot;Graphical models, message-passing algorithms, and convex optimization.&quot;
 *
 * The batches are chosen according to a coloring.  For background on graph colorings for inference,
 * see for example:
 *  Gonzalez et al. &quot;Parallel Gibbs Sampling: From Colored Fields to Thin Junction Trees.&quot;
 *  AISTATS, 2011.
 *
 * The BP algorithm works by:
 *  - Coloring the graph by assigning a color to each vertex such that no neighboring vertices
 *    share the same color.
 *  - In each step of BP, update all vertices of a single color.  Alternate colors.
 */
object BeliefPropagation {

  def main(args: Array[String]): Unit = {
    val spark = SparkSession
      .builder()
      .appName(&quot;BeliefPropagation example&quot;)
      .getOrCreate()

    val sql = spark.sqlContext

    // Create graphical model g of size 3 x 3.
    val g = gridIsingModel(sql, 3)

    println(&quot;Original Ising model:&quot;)
    g.vertices.show()
    g.edges.show()

    // Run BP for 5 iterations.
    val numIter = 5
    val results = runBPwithGraphX(g, numIter)

    // Display beliefs.
    val beliefs = results.vertices.select(&quot;id&quot;, &quot;belief&quot;)
    println(s&quot;Done with BP. Final beliefs after $numIter iterations:&quot;)
    beliefs.show()

    spark.stop()
  }

  /**
   * Given a GraphFrame, choose colors for each vertex.  No neighboring vertices will share the
   * same color.  The number of colors is minimized.
   *
   * This is written specifically for grid graphs. For non-grid graphs, it should be generalized,
   * such as by using a greedy coloring scheme.
   *
   * @param g  Grid graph generated by [[org.graphframes.examples.Graphs.gridIsingModel()]]
   * @return  Same graph, but with a new vertex column &quot;color&quot; of type Int (0 or 1)
   */
  private def colorGraph(g: GraphFrame): GraphFrame = {
    val colorUDF = udf { (i: Int, j: Int) =&gt; (i + j) % 2 }
    val v = g.vertices.withColumn(&quot;color&quot;, colorUDF(col(&quot;i&quot;), col(&quot;j&quot;)))
    GraphFrame(v, g.edges)
  }

  /**
   * Run Belief Propagation.
   *
   * This implementation of BP shows how to use GraphX's aggregateMessages method.
   * It is simple to convert to and from GraphX format.  This method does the following:
   *  - Color GraphFrame vertices for BP scheduling.
   *  - Convert GraphFrame to GraphX format.
   *  - Run BP using GraphX's aggregateMessages API.
   *  - Augment the original GraphFrame with the BP results (vertex beliefs).
   *
   * @param g  Graphical model created by `org.graphframes.examples.Graphs.gridIsingModel()`
   * @param numIter  Number of iterations of BP to run.  One iteration includes updating each
   *                 vertex's belief once.
   * @return  Same graphical model, but with [[GraphFrame.vertices]] augmented with a new column
   *          &quot;belief&quot; containing P(x,,i,, = +1), the marginal probability of vertex i taking
   *          value +1 instead of -1.
   */
  def runBPwithGraphX(g: GraphFrame, numIter: Int): GraphFrame = {
    // Choose colors for vertices for BP scheduling.
    val colorG = colorGraph(g)
    val numColors: Int = colorG.vertices.select(&quot;color&quot;).distinct.count().toInt

    // Convert GraphFrame to GraphX, and initialize beliefs.
    val gx0 = colorG.toGraphX
    // Schema maps for extracting attributes
    val vColsMap = colorG.vertexColumnMap
    val eColsMap = colorG.edgeColumnMap
    // Convert vertex attributes to nice case classes.
    val gx1: Graph[VertexAttr, Row] = gx0.mapVertices { case (_, attr) =&gt;
      // Initialize belief at 0.0
      VertexAttr(attr.getDouble(vColsMap(&quot;a&quot;)), 0.0, attr.getInt(vColsMap(&quot;color&quot;)))
    }
    // Convert edge attributes to nice case classes.
    val extractEdgeAttr: (GXEdge[Row] =&gt; EdgeAttr) = { e =&gt;
      EdgeAttr(e.attr.getDouble(eColsMap(&quot;b&quot;)))
    }
    var gx: Graph[VertexAttr, EdgeAttr] = gx1.mapEdges(extractEdgeAttr)

    // Run BP for numIter iterations.
    for (iter &lt;- Range(0, numIter)) {
      // For each color, have that color receive messages from neighbors.
      for (color &lt;- Range(0, numColors)) {
        // Send messages to vertices of the current color.
        val msgs: VertexRDD[Double] = gx.aggregateMessages(
          ctx =&gt;
            // Can send to source or destination since edges are treated as undirected.
            if (ctx.dstAttr.color == color) {
              val msg = ctx.attr.b * ctx.srcAttr.belief
              // Only send message if non-zero.
              if (msg != 0) ctx.sendToDst(msg)
            } else if (ctx.srcAttr.color == color) {
              val msg = ctx.attr.b * ctx.dstAttr.belief
              // Only send message if non-zero.
              if (msg != 0) ctx.sendToSrc(msg)
            },
          _ + _)
        // Receive messages, and update beliefs for vertices of the current color.
        gx = gx.outerJoinVertices(msgs) {
          case (vID, vAttr, optMsg) =&gt;
            if (vAttr.color == color) {
              val x = vAttr.a + optMsg.getOrElse(0.0)
              val newBelief = math.exp(-log1pExp(-x))
              VertexAttr(vAttr.a, newBelief, color)
            } else {
              vAttr
            }
        }
      }
    }

    // Convert back to GraphFrame with a new column &quot;belief&quot; for vertices DataFrame.
    val gxFinal: Graph[Double, Unit] = gx.mapVertices((_, attr) =&gt; attr.belief).mapEdges(_ =&gt; ())
    GraphFrame.fromGraphX(colorG, gxFinal, vertexNames = Seq(&quot;belief&quot;))
  }

  case class VertexAttr(a: Double, belief: Double, color: Int)

  case class EdgeAttr(b: Double)

  /**
   * Run Belief Propagation.
   *
   * This implementation of BP shows how to use GraphFrame's aggregateMessages method.
   *  - Color GraphFrame vertices for BP scheduling.
   *  - Run BP using GraphFrame's aggregateMessages API.
   *  - Augment the original GraphFrame with the BP results (vertex beliefs).
   *
   * @param g  Graphical model created by `org.graphframes.examples.Graphs.gridIsingModel()`
   * @param numIter  Number of iterations of BP to run.  One iteration includes updating each
   *                 vertex's belief once.
   * @return  Same graphical model, but with [[GraphFrame.vertices]] augmented with a new column
   *          &quot;belief&quot; containing P(x,,i,, = +1), the marginal probability of vertex i taking
   *          value +1 instead of -1.
   */
  def runBPwithGraphFrames(g: GraphFrame, numIter: Int): GraphFrame = {
    // Choose colors for vertices for BP scheduling.
    val colorG = colorGraph(g)
    val numColors: Int = colorG.vertices.select(&quot;color&quot;).distinct.count().toInt

    // TODO: Handle vertices without any edges.

    // Initialize vertex beliefs at 0.0.
    var gx = GraphFrame(colorG.vertices.withColumn(&quot;belief&quot;, lit(0.0)), colorG.edges)

    // Run BP for numIter iterations.
    for (iter &lt;- Range(0, numIter)) {
      // For each color, have that color receive messages from neighbors.
      for (color &lt;- Range(0, numColors)) {
        // Define &quot;AM&quot; for shorthand for referring to the src, dst, edge, and msg fields.
        // (See usage below.)
        val AM = AggregateMessages
        // Send messages to vertices of the current color.
        // We may send to source or destination since edges are treated as undirected.
        val msgForSrc: Column = when(AM.src(&quot;color&quot;) === color, AM.edge(&quot;b&quot;) * AM.dst(&quot;belief&quot;))
        val msgForDst: Column = when(AM.dst(&quot;color&quot;) === color, AM.edge(&quot;b&quot;) * AM.src(&quot;belief&quot;))
        val logistic = udf { (x: Double) =&gt; math.exp(-log1pExp(-x)) }
        val aggregates = gx.aggregateMessages
          .sendToSrc(msgForSrc)
          .sendToDst(msgForDst)
          .agg(sum(AM.msg).as(&quot;aggMess&quot;))
        val v = gx.vertices
        // Receive messages, and update beliefs for vertices of the current color.
        val newBeliefCol = when(v(&quot;color&quot;) === color &amp;&amp; aggregates(&quot;aggMess&quot;).isNotNull,
          logistic(aggregates(&quot;aggMess&quot;) + v(&quot;a&quot;)))
          .otherwise(v(&quot;belief&quot;))  // keep old beliefs for other colors
        val newVertices = v
          .join(aggregates, v(&quot;id&quot;) === aggregates(&quot;id&quot;), &quot;left_outer&quot;)  // join messages, vertices
          .drop(aggregates(&quot;id&quot;))  // drop duplicate ID column (from outer join)
          .withColumn(&quot;newBelief&quot;, newBeliefCol)  // compute new beliefs
          .drop(&quot;aggMess&quot;)  // drop messages
          .drop(&quot;belief&quot;)  // drop old beliefs
          .withColumnRenamed(&quot;newBelief&quot;, &quot;belief&quot;)
        // Cache new vertices using workaround for SPARK-13346
        val cachedNewVertices = AM.getCachedDataFrame(newVertices)
        gx = GraphFrame(cachedNewVertices, gx.edges)
      }
    }

    // Drop the &quot;color&quot; column from vertices
    GraphFrame(gx.vertices.drop(&quot;color&quot;), gx.edges)
  }

  /** More numerically stable `log(1 + exp(x))` */
  private def log1pExp(x: Double): Double = {
    if (x &gt; 0) {
      x + math.log1p(math.exp(-x))
    } else {
      math.log1p(math.exp(x))
    }
  }
}
</code></pre>
</div>
<div class="cell code" execution_count="1" scrolled="false">
</div>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../contents/000_2-sds-3-x-ml/021_recognizeActivityByRandomForest.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../../contents/000_2-sds-3-x-ml/023_OnTimeFlightPerformance.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../contents/000_2-sds-3-x-ml/021_recognizeActivityByRandomForest.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../../contents/000_2-sds-3-x-ml/023_OnTimeFlightPerformance.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="../../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
