<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>027_TweetCollectorTrackAndFollow - sds-3.x/ScaDaMaLe</title>


        <!-- Custom HTML head -->

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../../scroll-mdbook-outputs.css">

        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../../contents/000_3-sds-3-x-st/024_SparkStreamingIntro.html">024_SparkStreamingIntro</a></li><li class="chapter-item expanded affix "><a href="../../contents/000_3-sds-3-x-st/025_0_getTwitterDeveloperCredentials.html">025_0_getTwitterDeveloperCredentials</a></li><li class="chapter-item expanded affix "><a href="../../contents/000_3-sds-3-x-st/025_a_extendedTwitterUtils2run.html">025_a_extendedTwitterUtils2run</a></li><li class="chapter-item expanded affix "><a href="../../contents/000_3-sds-3-x-st/025_b_TTTDFfunctions.html">025_b_TTTDFfunctions</a></li><li class="chapter-item expanded affix "><a href="../../contents/000_3-sds-3-x-st/025_c_extendedTwitterUtils2runWithLangs.html">025_c_extendedTwitterUtils2runWithLangs</a></li><li class="chapter-item expanded affix "><a href="../../contents/000_3-sds-3-x-st/026_TweetCollector.html">026_TweetCollector</a></li><li class="chapter-item expanded affix "><a href="../../contents/000_3-sds-3-x-st/027_TweetCollectorTrackAndFollow.html" class="active">027_TweetCollectorTrackAndFollow</a></li><li class="chapter-item expanded affix "><a href="../../contents/000_3-sds-3-x-st/028_TweetHashtagCount.html">028_TweetHashtagCount</a></li><li class="chapter-item expanded affix "><a href="../../contents/000_3-sds-3-x-st/029_TweetLanguageClassifier.html">029_TweetLanguageClassifier</a></li><li class="chapter-item expanded affix "><a href="../../contents/000_3-sds-3-x-st/029_Viz_0_TwitterInteractiveVizualisations.html">029_Viz_0_TwitterInteractiveVizualisations</a></li><li class="chapter-item expanded affix "><a href="../../contents/000_3-sds-3-x-st/029_Viz_1_GraphNetworkTimeline.html">029_Viz_1_GraphNetworkTimeline</a></li><li class="chapter-item expanded affix "><a href="../../contents/000_3-sds-3-x-st/029_Viz_2_CoSENSE_EmotionalDimensions.html">029_Viz_2_CoSENSE_EmotionalDimensions</a></li><li class="chapter-item expanded affix "><a href="../../contents/000_3-sds-3-x-st/029_Viz_x_VizGraphFunction.html">029_Viz_x_VizGraphFunction</a></li><li class="chapter-item expanded affix "><a href="../../contents/000_3-sds-3-x-st/029_Viz_x_VizNetworkFunction.html">029_Viz_x_VizNetworkFunction</a></li><li class="chapter-item expanded affix "><a href="../../contents/000_3-sds-3-x-st/029_Viz_x_VizTimelineFunction.html">029_Viz_x_VizTimelineFunction</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">sds-3.x/ScaDaMaLe</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <div class="cell markdown">
<p>ScaDaMaLe Course <a href="https://lamastex.github.io/scalable-data-science/sds/3/x/">site</a> and <a href="https://lamastex.github.io/ScaDaMaLe/index.html">book</a></p>
</div>
<div class="cell markdown">
<h1 id="tweet-streaming-collector---track--follow"><a class="header" href="#tweet-streaming-collector---track--follow">Tweet Streaming Collector - Track &amp; Follow</a></h1>
<p>In the previous notebook we were capturing tweets from the public streams under the assumption that it is a random sample of roughly 1% of all tweets.</p>
<p>In this notebook, we can modify the collector to focus on specific communications of interest to us. Specifically, by including:</p>
<ul>
<li>a list of strings to track and</li>
<li>a list of twitter user-IDs of interest to follow.</li>
</ul>
<p>For this we will first <code>%run</code> the <code>ExtendedTwitterUtils</code> and <code>TTTDFfunctions</code> notebooks.</p>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-run">&quot;./025_a_extendedTwitterUtils2run&quot;
</code></pre>
</div>
<div class="cell code" execution_count="1" scrolled="false">
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-run">&quot;./025_b_TTTDFfunctions&quot;
</code></pre>
</div>
<div class="cell code" execution_count="1" scrolled="false">
</div>
<div class="cell code" execution_count="1" scrolled="false">
<div class="output execute_result plain_result" execution_count="1">
<pre><code>import twitter4j._
import twitter4j.auth.Authorization
import twitter4j.conf.ConfigurationBuilder
import twitter4j.auth.OAuthAuthorization
import org.apache.spark.streaming._
import org.apache.spark.streaming.dstream._
import org.apache.spark.storage.StorageLevel
import org.apache.spark.streaming.receiver.Receiver
</code></pre>
</div>
</div>
<div class="cell markdown">
<p>Go to SparkUI and see if a streaming job is already running. If so you need to terminate it before starting a new streaming job. Only one streaming job can be run on the DB CE.</p>
</div>
<div class="cell code" execution_count="1" scrolled="false">
</div>
<div class="cell code" execution_count="1" scrolled="false">
</div>
<div class="cell code" execution_count="1" scrolled="false">
<div class="output execute_result plain_result" execution_count="1">
<pre><code>defined class ExtendedTwitterReceiver
</code></pre>
</div>
</div>
<div class="cell code" execution_count="1" scrolled="false">
</div>
<div class="cell code" execution_count="1" scrolled="false">
<div class="output execute_result plain_result" execution_count="1">
<pre><code>defined class ExtendedTwitterInputDStream
</code></pre>
</div>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-scala">// this will make sure all streaming job in the cluster are stopped
StreamingContext.getActive.foreach{ _.stop(stopSparkContext = false) } 
</code></pre>
</div>
<div class="cell code" execution_count="1" scrolled="false">
</div>
<div class="cell code" execution_count="1" scrolled="false">
<div class="output execute_result plain_result" execution_count="1">
<pre><code>USAGE: val df = tweetsDF2TTTDF(tweetsJsonStringDF2TweetsDF(fromParquetFile2DF(&quot;parquetFileName&quot;)))
                  val df = tweetsDF2TTTDF(tweetsIDLong_JsonStringPairDF2TweetsDF(fromParquetFile2DF(&quot;parquetFileName&quot;)))
                  
import org.apache.spark.sql.types.{StructType, StructField, StringType}
import org.apache.spark.sql.functions._
import org.apache.spark.sql.types._
import org.apache.spark.sql.ColumnName
import org.apache.spark.sql.DataFrame
fromParquetFile2DF: (InputDFAsParquetFilePatternString: String)org.apache.spark.sql.DataFrame
tweetsJsonStringDF2TweetsDF: (tweetsAsJsonStringInputDF: org.apache.spark.sql.DataFrame)org.apache.spark.sql.DataFrame
tweetsIDLong_JsonStringPairDF2TweetsDF: (tweetsAsIDLong_JsonStringInputDF: org.apache.spark.sql.DataFrame)org.apache.spark.sql.DataFrame
tweetsDF2TTTDF: (tweetsInputDF: org.apache.spark.sql.DataFrame)org.apache.spark.sql.DataFrame
tweetsDF2TTTDFWithURLsAndHashtags: (tweetsInputDF: org.apache.spark.sql.DataFrame)org.apache.spark.sql.DataFrame
</code></pre>
</div>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<div class="output execute_result plain_result" execution_count="1">
<pre><code>import twitter4j.Status
import twitter4j.auth.Authorization
import org.apache.spark.storage.StorageLevel
import org.apache.spark.streaming.StreamingContext
import org.apache.spark.streaming.dstream.{ReceiverInputDStream, DStream}
defined object ExtendedTwitterUtils
</code></pre>
</div>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<div class="output execute_result plain_result" execution_count="1">
<pre><code>done running the extendedTwitterUtils2run notebook - ready to stream from twitter
</code></pre>
</div>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<div class="output execute_result plain_result" execution_count="1">
<pre><code>tweetsDF2TTTDFLightWeight: (tweetsInputDF: org.apache.spark.sql.DataFrame)org.apache.spark.sql.DataFrame
tweetsDF2TTTDFWithURLsAndHashtagsLightWeight: (tweetsInputDF: org.apache.spark.sql.DataFrame)org.apache.spark.sql.DataFrame
</code></pre>
</div>
</div>
<div class="cell markdown">
<p>Load your twitter credentials (secretly!).</p>
</div>
<div class="cell markdown">
<p><strong>Enter your Twitter API Credentials.</strong></p>
<ul>
<li>Go to https://apps.twitter.com and look up your Twitter API Credentials, or create an app to create them.</li>
<li>Run the code in a cell to Enter your own credentials.</li>
</ul>
<pre><code class="language-%scala">// put your own twitter developer credentials below instead of xxx
// instead of the '%run &quot;.../secrets/026_secret_MyTwitterOAuthCredentials&quot;' below
// you need to copy-paste the following code-block with your own Twitter credentials replacing XXXX


// put your own twitter developer credentials below 

import twitter4j.auth.OAuthAuthorization
import twitter4j.conf.ConfigurationBuilder


// These have been regenerated!!! - need to chane them

def myAPIKey       = &quot;XXXX&quot; // APIKey 
def myAPISecret    = &quot;XXXX&quot; // APISecretKey
def myAccessToken          = &quot;XXXX&quot; // AccessToken
def myAccessTokenSecret    = &quot;XXXX&quot; // AccessTokenSecret


System.setProperty(&quot;twitter4j.oauth.consumerKey&quot;, myAPIKey)
System.setProperty(&quot;twitter4j.oauth.consumerSecret&quot;, myAPISecret)
System.setProperty(&quot;twitter4j.oauth.accessToken&quot;, myAccessToken)
System.setProperty(&quot;twitter4j.oauth.accessTokenSecret&quot;, myAccessTokenSecret)

println(&quot;twitter OAuth Credentials loaded&quot;)
</code></pre>
<p>The cell-below will not expose my Twitter API Credentials: <code>myAPIKey</code>, <code>myAPISecret</code>, <code>myAccessToken</code> and <code>myAccessTokenSecret</code>. Use the code above to enter your own credentials in a scala cell.</p>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-run">&quot;Users/raazesh.sainudiin@math.uu.se/scalable-data-science/secrets/026_secret_MyTwitterOAuthCredentials&quot;
</code></pre>
</div>
<div class="cell markdown">
<h2 id="using-twitter-rest-api"><a class="header" href="#using-twitter-rest-api">Using Twitter REST API</a></h2>
<p>Next we import and instantiate for Twitter REST API, which allows us to obtain data from Twitter that is not in the live stream but in Twitter's storage layers containing archives of historcial events (including past status updates).</p>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-scala">// SOME IMPORTTS
import scala.collection.mutable.ArrayBuffer
import twitter4j._
import twitter4j.conf._
import scala.collection.JavaConverters._ 

import org.apache.spark.sql.Row;
import org.apache.spark.sql.types.{StructType, StructField, StringType};
import twitter4j.RateLimitStatus;
import twitter4j.ResponseList;
import com.google.gson.Gson
import org.apache.spark.sql.functions._
import org.apache.spark.sql.types._
import com.google.gson.Gson
import org.apache.spark.sql.DataFrame

val cb = new ConfigurationBuilder()       

val twitter = {
  val c = new ConfigurationBuilder
    c.setDebugEnabled(false)
    .setOAuthConsumerKey(myAPIKey)
    .setOAuthConsumerSecret(myAPISecret)
    .setOAuthAccessToken(myAccessToken)
    .setOAuthAccessTokenSecret(myAccessTokenSecret);

  new TwitterFactory(c.build()).getInstance()
}
</code></pre>
<div class="output execute_result plain_result" execution_count="1">
<pre><code>import scala.collection.mutable.ArrayBuffer
import twitter4j._
import twitter4j.conf._
import scala.collection.JavaConverters._
import org.apache.spark.sql.Row
import org.apache.spark.sql.types.{StructType, StructField, StringType}
import twitter4j.RateLimitStatus
import twitter4j.ResponseList
import com.google.gson.Gson
import org.apache.spark.sql.functions._
import org.apache.spark.sql.types._
import com.google.gson.Gson
import org.apache.spark.sql.DataFrame
cb: twitter4j.conf.ConfigurationBuilder = twitter4j.conf.ConfigurationBuilder@4559b2a7
twitter: twitter4j.Twitter = TwitterImpl{INCLUDE_MY_RETWEET=HttpParameter{name='include_my_retweet', value='true', jsonObject=null, file=null, fileBody=null}}
</code></pre>
</div>
</div>
<div class="cell markdown">
<h3 id="testing-rest-api"><a class="header" href="#testing-rest-api">Testing REST API</a></h3>
<p>Let's quickly test that the REST API calls can be made.</p>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-scala">twitter.showUser(&quot;@raazozone&quot;).getId() // quick test that REST API works - should get 4173723312
</code></pre>
<div class="output execute_result plain_result" execution_count="1">
<pre><code>res4: Long = 4173723312
</code></pre>
</div>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-scala">twitter.showUser(&quot;@realDonaldTrump&quot;).getId() // quick test that REST API works - should get 25073877
</code></pre>
<div class="output execute_result plain_result" execution_count="1">
<pre><code>res5: Long = 25073877
</code></pre>
</div>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-scala">twitter.showUser(&quot;@WASP_Research&quot;).getId() // quick test that REST API works - should get ?
</code></pre>
<div class="output execute_result plain_result" execution_count="1">
<pre><code>res6: Long = 1124265687755755520
</code></pre>
</div>
</div>
<div class="cell markdown">
<h3 id="creating-screennames-of-interest"><a class="header" href="#creating-screennames-of-interest">Creating ScreenNames of Interest</a></h3>
<p>Let's import a list of twitterIDS of interest to us...</p>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-scala">val screenNamesOfInterest = List(&quot;raazozone&quot;,&quot;realDonaldTrump&quot;,&quot;WASP_Research&quot;) // could be done from a large list of up to 4,000 or so accounts
</code></pre>
<div class="output execute_result plain_result" execution_count="1">
<pre><code>screenNamesOfInterest: List[String] = List(raazozone, realDonaldTrump, WASP_Research)
</code></pre>
</div>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-scala">def lookupUserSNs(Retweeterids:Seq[String])={
  val grouped=Retweeterids.grouped(100).toList 
  for {group&lt;-grouped  
       users=twitter.lookupUsers(group:_*)
       user&lt;-users.asScala 
   } yield user     
}// we loose some suspended accounts...

def lookupUsers(Retweeterids:Seq[Long])={
  val grouped=Retweeterids.grouped(100).toList 
  for {group&lt;-grouped  
       users=twitter.lookupUsers(group:_*)
       user&lt;-users.asScala 
   } yield user     
}// we loose some suspended accounts...
</code></pre>
<div class="output execute_result plain_result" execution_count="1">
<pre><code>lookupUserSNs: (Retweeterids: Seq[String])List[twitter4j.User]
lookupUsers: (Retweeterids: Seq[Long])List[twitter4j.User]
</code></pre>
</div>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-scala">val twitterUsersOfInterest = lookupUserSNs(screenNamesOfInterest) // not displayed
</code></pre>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-scala">println(twitterUsersOfInterest.size, screenNamesOfInterest.size) // we could lose users due to suspended accounts etc...
</code></pre>
<div class="output execute_result plain_result" execution_count="1">
<pre><code>(3,3)
</code></pre>
</div>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-scala">// just get their IDs
val seedIDs = twitterUsersOfInterest.map(u =&gt; u.getId()).toSet.toSeq.filter(_.isValidLong) // just get the IDs of the seed users who are valid
</code></pre>
<div class="output execute_result plain_result" execution_count="1">
<pre><code>seedIDs: Seq[Long] = Vector(4173723312, 25073877, 1124265687755755520)
</code></pre>
</div>
</div>
<div class="cell markdown">
<h3 id="extending-streamfunc-to-track--follow"><a class="header" href="#extending-streamfunc-to-track--follow">Extending <code>streamFunc</code> to Track &amp; Follow</a></h3>
<p>Now, let's extend our function to be able to track and follow.</p>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-scala">import com.google.gson.Gson 
import org.apache.spark.sql.functions._
import org.apache.spark.sql.types._

val outputDirectoryRoot = &quot;/datasets/tweetsStreamTmp&quot; // output directory
val batchInterval = 1 // in minutes
val timeoutJobLength =  batchInterval * 5

var newContextCreated = false
var numTweetsCollected = 0L // track number of tweets collected
//val conf = new SparkConf().setAppName(&quot;TrackedTweetCollector&quot;).setMaster(&quot;local&quot;)
// This is the function that creates the SteamingContext and sets up the Spark Streaming job.
def streamFunc(): StreamingContext = {
  // Create a Spark Streaming Context.
  val ssc = new StreamingContext(sc, Minutes(batchInterval))
  // Create the OAuth Twitter credentials 
  val auth = Some(new OAuthAuthorization(new ConfigurationBuilder().build()))
  
  val track = List(&quot;WASP rules!&quot;, &quot;#MakeDataGreatAgain&quot;,&quot;sds-3-x rules!&quot;)//, &quot;Hi&quot;)// just added for some live tests
  //val track = List.empty // if you do not want to track by any string
  
  val follow = seedIDs // who to follow in Twitter
  //val follow = List.empty // if you do not want to folow any specific twitter user
  
  // Create a Twitter Stream for the input source.  
  val twitterStream = ExtendedTwitterUtils.createStream(ssc, auth, track, follow)
  // Transform the discrete RDDs into JSON
  val twitterStreamJson = twitterStream.map(x =&gt; { val gson = new Gson();
                                                 val xJson = gson.toJson(x)
                                                 xJson
                                               }) 
  // take care
  val partitionsEachInterval = 1 // This tells the number of partitions in each RDD of tweets in the DStream.
  
  // what we want done with each discrete RDD tuple: (rdd, time)
  twitterStreamJson.foreachRDD((rdd, time) =&gt; { // for each filtered RDD in the DStream
      val count = rdd.count()
      if (count &gt; 0) {
        val outputRDD = rdd.repartition(partitionsEachInterval) // repartition as desired
        // to write to parquet directly in append mode in one directory per 'time'------------       
        val outputDF = outputRDD.toDF(&quot;tweetAsJsonString&quot;)
        // get some time fields from current `.Date()`
        val year = (new java.text.SimpleDateFormat(&quot;yyyy&quot;)).format(new java.util.Date())
        val month = (new java.text.SimpleDateFormat(&quot;MM&quot;)).format(new java.util.Date())
        val day = (new java.text.SimpleDateFormat(&quot;dd&quot;)).format(new java.util.Date())
        val hour = (new java.text.SimpleDateFormat(&quot;HH&quot;)).format(new java.util.Date())
        // write to a file with a clear time-based hierarchical directory structure for example
        outputDF.write.mode(SaveMode.Append)
                .parquet(outputDirectoryRoot+ &quot;/&quot;+ year + &quot;/&quot; + month + &quot;/&quot; + day + &quot;/&quot; + hour + &quot;/&quot; + time.milliseconds) 
        // end of writing as parquet file-------------------------------------
        numTweetsCollected += count // update with the latest count
      }
  })
  newContextCreated = true
  ssc
}
</code></pre>
<div class="output execute_result plain_result" execution_count="1">
<pre><code>import com.google.gson.Gson
import org.apache.spark.sql.functions._
import org.apache.spark.sql.types._
outputDirectoryRoot: String = /datasets/tweetsStreamTmp
batchInterval: Int = 1
timeoutJobLength: Int = 5
newContextCreated: Boolean = false
numTweetsCollected: Long = 0
streamFunc: ()org.apache.spark.streaming.StreamingContext
</code></pre>
</div>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<div class="output execute_result plain_result" execution_count="1">
<pre><code>twitter OAuth Credentials loaded
import twitter4j.auth.OAuthAuthorization
import twitter4j.conf.ConfigurationBuilder
import twitter4j.auth.OAuthAuthorization
import twitter4j.conf.ConfigurationBuilder
myAPIKey: String
myAPISecret: String
myAccessToken: String
myAccessTokenSecret: String
</code></pre>
</div>
</div>
<div class="cell markdown">
<h3 id="collect-verify-and-explore"><a class="header" href="#collect-verify-and-explore">Collect, Verify and Explore</a></h3>
<p>Let us collect data, store it and then explore it to see how our new experimental design changes to the Tweet collector actually performs.</p>
<p>You should ideally be doing live Tweets using your Twitter accounts as you are doing the experiment so you can confirm that your collector actually captures what you inted to. For example, retweet a userID in the list of userIDs you are following to check if this retweet ends up in your collector as expected. You can also tweet string of interest in the list of strings you are tracking.</p>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-scala">val ssc = StreamingContext.getActiveOrCreate(streamFunc)
</code></pre>
<div class="output execute_result plain_result" execution_count="1">
<pre><code>ssc: org.apache.spark.streaming.StreamingContext = org.apache.spark.streaming.StreamingContext@54fb3d50
</code></pre>
</div>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-scala">ssc.start()
//ssc.awaitTerminationOrTimeout(timeoutJobLength) // you only need one of these to start
</code></pre>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-scala">display(dbutils.fs.ls(&quot;/datasets/tweetsStreamTmp/2020/11/20/10/&quot;))
</code></pre>
<div class="output execute_result tabular_result" execution_count="1">
<table>
<thead>
<tr class="header">
<th>path</th>
<th>name</th>
<th>size</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>dbfs:/datasets/tweetsStreamTmp/2020/11/20/10/1605868860000/</td>
<td>1605868860000/</td>
<td>0.0</td>
</tr>
<tr class="even">
<td>dbfs:/datasets/tweetsStreamTmp/2020/11/20/10/1605868920000/</td>
<td>1605868920000/</td>
<td>0.0</td>
</tr>
<tr class="odd">
<td>dbfs:/datasets/tweetsStreamTmp/2020/11/20/10/1605868980000/</td>
<td>1605868980000/</td>
<td>0.0</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-scala">display(dbutils.fs.ls(outputDirectoryRoot+&quot;/2020/11/20/10/1605868860000/&quot;)) // keep adding sub-dirs and descent into time-tree'd directory hierarchy
</code></pre>
<div class="output execute_result tabular_result" execution_count="1">
<table>
<thead>
<tr class="header">
<th>path</th>
<th>name</th>
<th>size</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>dbfs:/datasets/tweetsStreamTmp/2020/11/20/10/1605868860000/_SUCCESS</td>
<td>_SUCCESS</td>
<td>0.0</td>
</tr>
<tr class="even">
<td>dbfs:/datasets/tweetsStreamTmp/2020/11/20/10/1605868860000/_committed_7377493726042826738</td>
<td>_committed_7377493726042826738</td>
<td>125.0</td>
</tr>
<tr class="odd">
<td>dbfs:/datasets/tweetsStreamTmp/2020/11/20/10/1605868860000/_started_7377493726042826738</td>
<td>_started_7377493726042826738</td>
<td>0.0</td>
</tr>
<tr class="even">
<td>dbfs:/datasets/tweetsStreamTmp/2020/11/20/10/1605868860000/part-00000-tid-7377493726042826738-363f9903-0ada-41ff-92fd-c87b1349727d-6412-1-c000.snappy.parquet</td>
<td>part-00000-tid-7377493726042826738-363f9903-0ada-41ff-92fd-c87b1349727d-6412-1-c000.snappy.parquet</td>
<td>95863.0</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-scala">val rawDF = fromParquetFile2DF(outputDirectoryRoot+&quot;/2020/11/*/*/*/*&quot;) //.cache()
rawDF.count
</code></pre>
<div class="output execute_result plain_result" execution_count="1">
<pre><code>rawDF: org.apache.spark.sql.DataFrame = [tweetAsJsonString: string]
res15: Long = 437
</code></pre>
</div>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-scala">val TTTsDF = tweetsDF2TTTDF(tweetsJsonStringDF2TweetsDF(rawDF)).cache()
</code></pre>
</div>
<div class="cell markdown">
<p>Collect for a few minutes so all fields are availabale in the Tweets... otherwise you will get errors like this (which may be unavidable if what you are tracking has no <code>geoLocation</code> information for example, only a small fraction of Tweets have this information):</p>
<blockquote>
<p>&quot;org.apache.spark.sql.AnalysisException: cannot resolve '<code>geoLocation.latitude</code>' given input columns: [contributorsIDs, createdAt, currentUserRetweetId, displayTextRangeEnd, displayTextRangeStart, favoriteCount, hashtagEntities, id, inReplyToScreenName, inReplyToStatusId, inReplyToUserId, isFavorited, isPossiblySensitive, isRetweeted, isTruncated, lang, mediaEntities, place, quotedStatus, quotedStatusId, quotedStatusPermalink, retweetCount, retweetedStatus, source, symbolEntities, text, urlEntities, user, userMentionEntities, withheldInCountries];;&quot;</p>
</blockquote>
<p>We can parse more robustly... but let's go and modify the function so it does not look for the missing fields in these tweeets...</p>
<p><strong>NOTE</strong> In certain experiments all the user-IDs being tracked may not have enabled <code>geoLocation</code> information. In such cases, you can use the <code>tweetsDF2TTTDFLightWeight</code> to obtain the TTTDF from the raw tweets.</p>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-run">&quot;./025_b_TTTDFfunctions&quot;
</code></pre>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-scala">val TTTsDF = tweetsDF2TTTDFLightWeight(tweetsJsonStringDF2TweetsDF(rawDF)).cache()
</code></pre>
<div class="output execute_result plain_result" execution_count="1">
<pre><code>TTTsDF: org.apache.spark.sql.Dataset[org.apache.spark.sql.Row] = [CurrentTweetDate: timestamp, CurrentTwID: bigint ... 33 more fields]
</code></pre>
</div>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-scala">display(TTTsDF)  // output not displayed to comply with Twitter Developer rules
</code></pre>
</div>
<div class="cell code" execution_count="1" scrolled="false">
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-scala">// this will make sure all streaming job in the cluster are stopped 
StreamingContext.getActive.foreach { _.stop(stopSparkContext = false) } 
</code></pre>
</div>
<div class="cell code" execution_count="1" scrolled="false">
</div>
<div class="cell code" execution_count="1" scrolled="false">
<div class="output execute_result plain_result" execution_count="1">
<pre><code>USAGE: val df = tweetsDF2TTTDF(tweetsJsonStringDF2TweetsDF(fromParquetFile2DF(&quot;parquetFileName&quot;)))
                  val df = tweetsDF2TTTDF(tweetsIDLong_JsonStringPairDF2TweetsDF(fromParquetFile2DF(&quot;parquetFileName&quot;)))
                  
import org.apache.spark.sql.types.{StructType, StructField, StringType}
import org.apache.spark.sql.functions._
import org.apache.spark.sql.types._
import org.apache.spark.sql.ColumnName
import org.apache.spark.sql.DataFrame
fromParquetFile2DF: (InputDFAsParquetFilePatternString: String)org.apache.spark.sql.DataFrame
tweetsJsonStringDF2TweetsDF: (tweetsAsJsonStringInputDF: org.apache.spark.sql.DataFrame)org.apache.spark.sql.DataFrame
tweetsIDLong_JsonStringPairDF2TweetsDF: (tweetsAsIDLong_JsonStringInputDF: org.apache.spark.sql.DataFrame)org.apache.spark.sql.DataFrame
tweetsDF2TTTDF: (tweetsInputDF: org.apache.spark.sql.DataFrame)org.apache.spark.sql.DataFrame
tweetsDF2TTTDFWithURLsAndHashtags: (tweetsInputDF: org.apache.spark.sql.DataFrame)org.apache.spark.sql.DataFrame
</code></pre>
</div>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-scala">val a = TTTsDF.filter($&quot;CurrentTweet&quot; contains &quot;WASP rules!&quot;)//.collect()
</code></pre>
<div class="output execute_result plain_result" execution_count="1">
<pre><code>a: org.apache.spark.sql.Dataset[org.apache.spark.sql.Row] = [CurrentTweetDate: timestamp, CurrentTwID: bigint ... 33 more fields]
</code></pre>
</div>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<div class="output execute_result plain_result" execution_count="1">
<pre><code>tweetsDF2TTTDFLightWeight: (tweetsInputDF: org.apache.spark.sql.DataFrame)org.apache.spark.sql.DataFrame
tweetsDF2TTTDFWithURLsAndHashtagsLightWeight: (tweetsInputDF: org.apache.spark.sql.DataFrame)org.apache.spark.sql.DataFrame
</code></pre>
</div>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-scala">display(a)
</code></pre>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-scala">val b = TTTsDF.filter($&quot;CurrentTweet&quot; contains &quot;#MakeDataGreatAgain&quot;)//.collect()
display(b) // output not displayed to comply with Twitter Developer rules
</code></pre>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-scala">// this will make sure all streaming job in the cluster are stopped - raaz
StreamingContext.getActive.foreach { _.stop(stopSparkContext = false) } 
</code></pre>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-scala">// this will delete what we collected to keep the disk usage tight and tidy
dbutils.fs.rm(outputDirectoryRoot, true) 
</code></pre>
<div class="output execute_result plain_result" execution_count="1">
<pre><code>res25: Boolean = true
</code></pre>
</div>
</div>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../contents/000_3-sds-3-x-st/026_TweetCollector.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../../contents/000_3-sds-3-x-st/028_TweetHashtagCount.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../contents/000_3-sds-3-x-st/026_TweetCollector.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../../contents/000_3-sds-3-x-st/028_TweetHashtagCount.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="../../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
