<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>007b_SparkSQLProgGuide_HW - sds-3.x/ScaDaMaLe</title>


        <!-- Custom HTML head -->

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../../scroll-mdbook-outputs.css">

        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../../contents/000_1-sds-3-x-sql/007_SparkSQLIntroBasics.html">007_SparkSQLIntroBasics</a></li><li class="chapter-item expanded affix "><a href="../../contents/000_1-sds-3-x-sql/007a_SparkSQLProgGuide_HW.html">007a_SparkSQLProgGuide_HW</a></li><li class="chapter-item expanded affix "><a href="../../contents/000_1-sds-3-x-sql/007b_SparkSQLProgGuide_HW.html" class="active">007b_SparkSQLProgGuide_HW</a></li><li class="chapter-item expanded affix "><a href="../../contents/000_1-sds-3-x-sql/007c_SparkSQLProgGuide_HW.html">007c_SparkSQLProgGuide_HW</a></li><li class="chapter-item expanded affix "><a href="../../contents/000_1-sds-3-x-sql/007d_SparkSQLProgGuide_HW.html">007d_SparkSQLProgGuide_HW</a></li><li class="chapter-item expanded affix "><a href="../../contents/000_1-sds-3-x-sql/007e_SparkSQLProgGuide_HW.html">007e_SparkSQLProgGuide_HW</a></li><li class="chapter-item expanded affix "><a href="../../contents/000_1-sds-3-x-sql/007f_SparkSQLProgGuide_HW.html">007f_SparkSQLProgGuide_HW</a></li><li class="chapter-item expanded affix "><a href="../../contents/000_1-sds-3-x-sql/007g_PivotInSQL.html">007g_PivotInSQL</a></li><li class="chapter-item expanded affix "><a href="../../contents/000_1-sds-3-x-sql/008_DiamondsPipeline_01ETLEDA.html">008_DiamondsPipeline_01ETLEDA</a></li><li class="chapter-item expanded affix "><a href="../../contents/000_1-sds-3-x-sql/009_PowerPlantPipeline_01ETLEDA.html">009_PowerPlantPipeline_01ETLEDA</a></li><li class="chapter-item expanded affix "><a href="../../contents/000_1-sds-3-x-sql/010_wikipediaClickStream_01ETLEDA.html">010_wikipediaClickStream_01ETLEDA</a></li><li class="chapter-item expanded affix "><a href="../../editors.html">Editors</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">sds-3.x/ScaDaMaLe</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <div class="cell markdown">
<p>ScaDaMaLe Course <a href="https://lamastex.github.io/scalable-data-science/sds/3/x/">site</a> and <a href="https://lamastex.github.io/ScaDaMaLe/index.html">book</a></p>
</div>
<div class="cell markdown">
<p>This is an elaboration of the <a href="http://spark.apache.org/docs/latest/sql-programming-guide.html">http://spark.apache.org/docs/latest/sql-programming-guide.html</a> by Ivan Sadikov and Raazesh Sainudiin.</p>
<h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<h2 id="spark-sql-programming-guide"><a class="header" href="#spark-sql-programming-guide">Spark Sql Programming Guide</a></h2>
<ul>
<li>Starting Point: SparkSession</li>
<li>Creating DataFrames</li>
<li>Untyped Dataset Operations (aka DataFrame Operations)</li>
<li>Running SQL Queries Programmatically</li>
<li>Global Temporary View</li>
<li>Creating Datasets</li>
<li>Interoperating with RDDs
<ul>
<li>Inferring the Schema Using Reflection</li>
<li>Programmatically Specifying the Schema</li>
</ul>
</li>
<li>Scalar Functions</li>
<li>Aggregate Functions</li>
</ul>
</div>
<div class="cell markdown">
<h1 id="getting-started-1"><a class="header" href="#getting-started-1">Getting Started</a></h1>
<h2 id="starting-point-sparksession"><a class="header" href="#starting-point-sparksession">Starting Point: SparkSession</a></h2>
<p>The entry point into all functionality in Spark is the <a href="https://spark.apache.org/docs/latest/api/scala/org/apache/spark/sql/SparkSession.html"><code>SparkSession</code></a> class and/or <code>SQLContext</code>/<code>HiveContext</code>. <code>SparkSession</code> is created for you as <code>spark</code> when you start <strong>spark-shell</strong> on command-line REPL or through a notebook server (databricks, zeppelin, jupyter, etc.). You will need to create <code>SparkSession</code> usually when building an application for submission to a Spark cluster. To create a basic <code>SparkSession</code>, just use <code>SparkSession.builder()</code>:</p>
<pre><code>import org.apache.spark.sql.SparkSession

val spark = SparkSession
  .builder()
  .appName(&quot;Spark SQL basic example&quot;)
  .config(&quot;spark.some.config.option&quot;, &quot;some-value&quot;)
  .getOrCreate()

// For implicit conversions like converting RDDs to DataFrames
import spark.implicits._
</code></pre>
<p>Find full example code in the Spark repo at:</p>
<ul>
<li><a href="https://github.com/apache/spark/blob/master/examples/src/main/scala/org/apache/spark/examples/sql/SparkSQLExample.scala">https://github.com/apache/spark/blob/master/examples/src/main/scala/org/apache/spark/examples/sql/SparkSQLExample.scala</a></li>
</ul>
<p><code>SparkSession</code> in Spark 2.0 provides builtin support for Hive features including the ability to write queries using HiveQL, access to Hive UDFs, and the ability to read data from Hive tables. To use these features, you do not need to have an existing Hive setup.</p>
<pre><code>// You could get SparkContext and SQLContext from SparkSession
val sc = spark.sparkContext
val sqlContext = spark.sqlContext
</code></pre>
<p>But in Databricks notebook (similar to <code>spark-shell</code>) <code>SparkSession</code> is already created for you and is available as <code>spark</code> (similarly, <code>sc</code> and <code>sqlContext</code> are also available).</p>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-scala">// Evaluation of the cell by Ctrl+Enter will print spark session available in notebook
spark
</code></pre>
<div class="output execute_result plain_result" execution_count="1">
<pre><code>res0: org.apache.spark.sql.SparkSession = org.apache.spark.sql.SparkSession@7f57ef36
</code></pre>
</div>
</div>
<div class="cell markdown">
<p>After evaluation you should see something like this, i.e., a reference to the <code>SparkSession</code> you just created:</p>
<pre><code>res0: org.apache.spark.sql.SparkSession = org.apache.spark.sql.SparkSession@5a289bf5
</code></pre>
</div>
<div class="cell markdown">
<h2 id="creating-dataframes"><a class="header" href="#creating-dataframes">Creating DataFrames</a></h2>
<p>With a <code>SparkSessions</code>, applications can create <a href="https://spark.apache.org/docs/latest/api/scala/org/apache/spark/sql/Dataset">Dataset</a> or <a href="https://spark.apache.org/docs/latest/api/scala/index.html#org.apache.spark.sql.DataFrame"><code>DataFrame</code></a> from an <a href="https://spark.apache.org/docs/latest/sql-getting-started.html#interoperating-with-rdds">existing <code>RDD</code></a>, from a Hive table, or from various <a href="https://spark.apache.org/docs/latest/sql-data-sources.html">datasources</a>.</p>
<p>Just to recap, a DataFrame is a distributed collection of data organized into named columns. You can think of it as an organized into table RDD of case class <code>Row</code> (which is not exactly true). DataFrames, in comparison to RDDs, are backed by rich optimizations, including tracking their own schema, adaptive query execution, code generation including whole stage codegen, extensible Catalyst optimizer, and project <a href="https://databricks.com/blog/2015/04/28/project-tungsten-bringing-spark-closer-to-bare-metal.html">Tungsten</a>.</p>
<p>Dataset provides type-safety when working with SQL, since <code>Row</code> is mapped to a case class, so that each column can be referenced by property of that class.</p>
<blockquote>
<p>Note that performance for Dataset/DataFrames is the same across languages Scala, Java, Python, and R. This is due to the fact that the planning phase is just language-specific, only logical plan is constructed in Python, and all the physical execution is compiled and executed as JVM bytecode.</p>
</blockquote>
</div>
<div class="cell markdown">
<p>As an example, the following creates a DataFrame based on the content of a JSON file:</p>
<pre><code>val df = spark.read.json(&quot;examples/src/main/resources/people.json&quot;)

// Displays the content of the DataFrame to stdout
df.show()
// +----+-------+
// | age|   name|
// +----+-------+
// |null|Michael|
// |  30|   Andy|
// |  19| Justin|
// +----+-------+
</code></pre>
<p>Find full example code at - https://raw.githubusercontent.com/apache/spark/master/examples/src/main/scala/org/apache/spark/examples/sql/SparkSQLExample.scala in the Spark repo.</p>
<p>To be able to try this example in databricks we need to load the <code>people.json</code> file into <code>dbfs</code>. Let us do this programmatically next.</p>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-scala">// you should not have to uncomment the block below as we already loaded data from 002_02_dbcCEdataLoader notebook
/*
// the following lines merely fetch the file from the URL and load it into the dbfs for us to try in databricks
// getLines from the file at the URL
val peopleJsonLinesFromURL = scala.io.Source.fromURL(&quot;https://raw.githubusercontent.com/apache/spark/master/examples/src/main/resources/people.json&quot;).getLines
// remove any pre-existing file at the dbfs location
dbutils.fs.rm(&quot;/datasets/sds/spark-examples/people.json&quot;,recurse=true)
// convert the lines fetched from the URL to a Seq, then make it a RDD of String and finally save it as textfile to dbfs
sc.parallelize(peopleJsonLinesFromURL.toSeq).saveAsTextFile(&quot;/datasets/sds/spark-examples/people.json&quot;)
*/
// read the text file we just saved or already loaded and see what it has
sc.textFile(&quot;/datasets/sds/spark-examples/people.json&quot;).collect.mkString(&quot;\n&quot;)
</code></pre>
<div class="output execute_result plain_result" execution_count="1">
<pre><code>res1: String =
{&quot;name&quot;:&quot;Michael&quot;}
{&quot;name&quot;:&quot;Andy&quot;, &quot;age&quot;:30}
{&quot;name&quot;:&quot;Justin&quot;, &quot;age&quot;:19}
</code></pre>
</div>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-scala">val df = spark.read.json(&quot;/datasets/sds/spark-examples/people.json&quot;)
</code></pre>
<div class="output execute_result plain_result" execution_count="1">
<pre><code>df: org.apache.spark.sql.DataFrame = [age: bigint, name: string]
</code></pre>
</div>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-scala">// you can also read into df like this - makes the same dataframe as the above call
val df = spark.read.format(&quot;json&quot;).load(&quot;/datasets/sds/spark-examples/people.json&quot;)
</code></pre>
<div class="output execute_result plain_result" execution_count="1">
<pre><code>df: org.apache.spark.sql.DataFrame = [age: bigint, name: string]
</code></pre>
</div>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-scala">df.show()
</code></pre>
<div class="output execute_result plain_result" execution_count="1">
<pre><code>+----+-------+
| age|   name|
+----+-------+
|  30|   Andy|
|  19| Justin|
|null|Michael|
+----+-------+
</code></pre>
</div>
</div>
<div class="cell markdown">
<h2 id="untyped-dataset-operations-aka-dataframe-operations"><a class="header" href="#untyped-dataset-operations-aka-dataframe-operations">Untyped Dataset Operations (aka DataFrame Operations)</a></h2>
<p>DataFrames provide a domain-specific language for structured data manipulation in <a href="https://spark.apache.org/docs/latest/api/scala/org/apache/spark/sql/Dataset.html">Scala</a>, <a href="https://spark.apache.org/docs/latest/api/java/index.html?org/apache/spark/sql/Dataset.html">Java</a>, <a href="https://spark.apache.org/docs/latest/api/python/reference/pyspark.sql/api/pyspark.sql.DataFrame.html">Python</a> and <a href="https://spark.apache.org/docs/latest/api/R/reference/SparkDataFrame.html">R</a>.</p>
<p>As mentioned above, in Spark 2.0 or higher, DataFrames are just Dataset of <code>Row</code>s in Scala and Java API. These operations are also referred as “untyped transformations” in contrast to “typed transformations” come with strongly typed Scala/Java Datasets.</p>
<p>Here we include some basic examples of structured data processing using Datasets:</p>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-scala">// This import is needed to use the $-notation
import spark.implicits._
// Print the schema in a tree format
df.printSchema()
</code></pre>
<div class="output execute_result plain_result" execution_count="1">
<pre><code>root
 |-- age: long (nullable = true)
 |-- name: string (nullable = true)

import spark.implicits._
</code></pre>
</div>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-scala">// Select only the &quot;name&quot; column
df.select(&quot;name&quot;).show()
</code></pre>
<div class="output execute_result plain_result" execution_count="1">
<pre><code>+-------+
|   name|
+-------+
|   Andy|
| Justin|
|Michael|
+-------+
</code></pre>
</div>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-scala">// Select everybody, but increment the age by 1
df.select($&quot;name&quot;, $&quot;age&quot; + 1).show()
</code></pre>
<div class="output execute_result plain_result" execution_count="1">
<pre><code>+-------+---------+
|   name|(age + 1)|
+-------+---------+
|   Andy|       31|
| Justin|       20|
|Michael|     null|
+-------+---------+
</code></pre>
</div>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-scala">// Select people older than 21
df.filter($&quot;age&quot; &gt; 21).show()
</code></pre>
<div class="output execute_result plain_result" execution_count="1">
<pre><code>+---+----+
|age|name|
+---+----+
| 30|Andy|
+---+----+
</code></pre>
</div>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-scala">// Count people by age
df.groupBy(&quot;age&quot;).count().show()
</code></pre>
<div class="output execute_result plain_result" execution_count="1">
<pre><code>+----+-----+
| age|count|
+----+-----+
|  19|    1|
|  30|    1|
|null|    1|
+----+-----+
</code></pre>
</div>
</div>
<div class="cell markdown">
<p>Find full example code at - https://raw.githubusercontent.com/apache/spark/master/examples/src/main/scala/org/apache/spark/examples/sql/SparkSQLExample.scala in the Spark repo.</p>
<p>For a complete list of the types of operations that can be performed on a Dataset, refer to the <a href="https://spark.apache.org/docs/latest/api/scala/org/apache/spark/sql/Dataset.html">API Documentation</a>.</p>
<p>In addition to simple column references and expressions, Datasets also have a rich library of functions including string manipulation, date arithmetic, common math operations and more. The complete list is available in the <a href="https://spark.apache.org/docs/latest/api/scala/org/apache/spark/sql/functions$.html">DataFrame Function Reference</a>.</p>
</div>
<div class="cell markdown">
<h2 id="running-sql-queries-programmatically"><a class="header" href="#running-sql-queries-programmatically">Running SQL Queries Programmatically</a></h2>
<p>The <code>sql</code> function on a <code>SparkSession</code> enables applications to run SQL queries programmatically and returns the result as a <code>DataFrame</code>.</p>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-scala">// Register the DataFrame as a SQL temporary view
df.createOrReplaceTempView(&quot;people&quot;)
</code></pre>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-scala">val sqlDF = spark.sql(&quot;SELECT * FROM people&quot;)
sqlDF.show()
</code></pre>
<div class="output execute_result plain_result" execution_count="1">
<pre><code>+----+-------+
| age|   name|
+----+-------+
|  30|   Andy|
|  19| Justin|
|null|Michael|
+----+-------+

sqlDF: org.apache.spark.sql.DataFrame = [age: bigint, name: string]
</code></pre>
</div>
</div>
<div class="cell markdown">
<h2 id="global-temporary-view"><a class="header" href="#global-temporary-view">Global Temporary View</a></h2>
<p>Temporary views in Spark SQL are session-scoped and will disappear if the session that creates it terminates. If you want to have a temporary view that is shared among all sessions and keep alive until the Spark application terminates, you can create a global temporary view. Global temporary view is tied to a system preserved database <code>global_temp</code>, and we must use the qualified name to refer it, e.g. <code>SELECT * FROM global_temp.view1</code>.</p>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-scala">// Register the DataFrame as a global temporary view
df.createGlobalTempView(&quot;people&quot;)
</code></pre>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-scala">// Global temporary view is tied to a system preserved database `global_temp`
spark.sql(&quot;SELECT * FROM global_temp.people&quot;).show()
</code></pre>
<div class="output execute_result plain_result" execution_count="1">
<pre><code>+----+-------+
| age|   name|
+----+-------+
|  30|   Andy|
|  19| Justin|
|null|Michael|
+----+-------+
</code></pre>
</div>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-scala">// Global temporary view is cross-session
spark.newSession().sql(&quot;SELECT * FROM global_temp.people&quot;).show()
</code></pre>
<div class="output execute_result plain_result" execution_count="1">
<pre><code>+----+-------+
| age|   name|
+----+-------+
|  30|   Andy|
|  19| Justin|
|null|Michael|
+----+-------+
</code></pre>
</div>
</div>
<div class="cell markdown">
<h2 id="creating-datasets"><a class="header" href="#creating-datasets">Creating Datasets</a></h2>
<p>See <a href="https://spark.apache.org/docs/latest/sql-getting-started.html#creating-datasets">https://spark.apache.org/docs/latest/sql-getting-started.html#creating-datasets</a></p>
<p>Datasets are similar to RDDs, however, instead of using Java serialization or Kryo they use a specialized <a href="https://spark.apache.org/docs/latest/api/scala/org/apache/spark/sql/Encoder.html">Encoder</a> to serialize the objects for processing or transmitting over the network. While both encoders and standard serialization are responsible for turning an object into bytes, encoders are code generated dynamically and use a format that allows Spark to perform many operations like filtering, sorting and hashing without deserializing the bytes back into an object.</p>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-scala">case class Person(name: String, age: Long)

// Encoders are created for case classes
val caseClassDS = Seq(Person(&quot;Andy&quot;, 32)).toDS()
caseClassDS.show()
</code></pre>
<div class="output execute_result plain_result" execution_count="1">
<pre><code>+----+---+
|name|age|
+----+---+
|Andy| 32|
+----+---+

defined class Person
caseClassDS: org.apache.spark.sql.Dataset[Person] = [name: string, age: bigint]
</code></pre>
</div>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-scala">// Encoders for most common types are automatically provided by importing spark.implicits._
val primitiveDS = Seq(1, 2, 3).toDS()
primitiveDS.map(_ + 1).collect() // Returns: Array(2, 3, 4)
</code></pre>
<div class="output execute_result plain_result" execution_count="1">
<pre><code>primitiveDS: org.apache.spark.sql.Dataset[Int] = [value: int]
res18: Array[Int] = Array(2, 3, 4)
</code></pre>
</div>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-scala">// DataFrames can be converted to a Dataset by providing a class. Mapping will be done by name
val path = &quot;/datasets/sds/spark-examples/people.json&quot;
val peopleDS = spark.read.json(path).as[Person]
peopleDS.show()
</code></pre>
<div class="output execute_result plain_result" execution_count="1">
<pre><code>+----+-------+
| age|   name|
+----+-------+
|  30|   Andy|
|  19| Justin|
|null|Michael|
+----+-------+

path: String = /datasets/sds/spark-examples/people.json
peopleDS: org.apache.spark.sql.Dataset[Person] = [age: bigint, name: string]
</code></pre>
</div>
</div>
<div class="cell markdown">
<p><strong>Dataset is not available directly in PySpark or SparkR</strong>.</p>
<h2 id="interoperating-with-rdds"><a class="header" href="#interoperating-with-rdds">Interoperating with RDDs</a></h2>
<p>Spark SQL supports two different methods for converting existing RDDs into Datasets. The first method uses reflection to infer the schema of an RDD that contains specific types of objects. This reflection-based approach leads to more concise code and works well when you already know the schema while writing your Spark application.</p>
<p>The second method for creating Datasets is through a programmatic interface that allows you to construct a schema and then apply it to an existing RDD. While this method is more verbose, it allows you to construct Datasets when the columns and their types are not known until runtime.</p>
<h3 id="inferring-the-schema-using-reflection"><a class="header" href="#inferring-the-schema-using-reflection">Inferring the Schema Using Reflection</a></h3>
<p>The Scala interface for Spark SQL supports automatically converting an RDD containing case classes to a DataFrame. The case class defines the schema of the table. The names of the arguments to the case class are read using reflection and become the names of the columns. Case classes can also be nested or contain complex types such as <code>Seq</code>s or <code>Array</code>s. This RDD can be implicitly converted to a DataFrame and then be registered as a table. Tables can be used in subsequent SQL statements.</p>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-scala">sc.textFile(&quot;/datasets/sds/spark-examples/people.txt&quot;).collect.mkString(&quot;\n&quot;)
</code></pre>
<div class="output execute_result plain_result" execution_count="1">
<pre><code>res22: String =
Michael, 29
Andy, 30
Justin, 19
</code></pre>
</div>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-scala">// For implicit conversions from RDDs to DataFrames
import spark.implicits._

// make a case class
case class Person(name: String, age: Long)

// Create an RDD of Person objects from a text file, convert it to a Dataframe
val peopleDF = spark.sparkContext
  .textFile(&quot;/datasets/sds/spark-examples/people.txt&quot;)
  .map(_.split(&quot;,&quot;))
  .map(attributes =&gt; Person(attributes(0), attributes(1).trim.toLong))
  .toDF()
</code></pre>
<div class="output execute_result plain_result" execution_count="1">
<pre><code>import spark.implicits._
defined class Person
peopleDF: org.apache.spark.sql.DataFrame = [name: string, age: bigint]
</code></pre>
</div>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-scala">peopleDF.show
</code></pre>
<div class="output execute_result plain_result" execution_count="1">
<pre><code>+-------+---+
|   name|age|
+-------+---+
|Michael| 29|
|   Andy| 30|
| Justin| 19|
+-------+---+
</code></pre>
</div>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-scala">// Register the DataFrame as a temporary view
peopleDF.createOrReplaceTempView(&quot;people&quot;)
</code></pre>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-scala">// SQL statements can be run by using the sql methods provided by Spark
val teenagersDF = spark.sql(&quot;SELECT name, age FROM people WHERE age BETWEEN 13 AND 19&quot;)
</code></pre>
<div class="output execute_result plain_result" execution_count="1">
<pre><code>teenagersDF: org.apache.spark.sql.DataFrame = [name: string, age: bigint]
</code></pre>
</div>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-scala">teenagersDF.show()
</code></pre>
<div class="output execute_result plain_result" execution_count="1">
<pre><code>+------+---+
|  name|age|
+------+---+
|Justin| 19|
+------+---+
</code></pre>
</div>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-scala">// The columns of a row in the result can be accessed by field index
teenagersDF.map(teenager =&gt; &quot;Name: &quot; + teenager(0)).show()
</code></pre>
<div class="output execute_result plain_result" execution_count="1">
<pre><code>+------------+
|       value|
+------------+
|Name: Justin|
+------------+
</code></pre>
</div>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-scala">// or by field name
teenagersDF.map(teenager =&gt; &quot;Name: &quot; + teenager.getAs[String](&quot;name&quot;)).show()
</code></pre>
<div class="output execute_result plain_result" execution_count="1">
<pre><code>+------------+
|       value|
+------------+
|Name: Justin|
+------------+
</code></pre>
</div>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-scala">// advanced ...
// No pre-defined encoders for Dataset[Map[K,V]], define explicitly
//implicit val mapEncoder = org.apache.spark.sql.Encoders.kryo[Map[String, Any]]
</code></pre>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-scala">// Primitive types and case classes can be also be defined as follows
// import more classes here...
//implicit val stringIntMapEncoder: Encoder[Map[String, Any]] = ExpressionEncoder()
</code></pre>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-scala">// row.getValuesMap[T] retrieves multiple columns at once into a Map[String, T]
//teenagersDF.map(teenager =&gt; teenager.getValuesMap[Any](List(&quot;name&quot;, &quot;age&quot;))).collect()
</code></pre>
</div>
<div class="cell markdown">
<h3 id="programmatically-specifying-the-schema"><a class="header" href="#programmatically-specifying-the-schema">Programmatically Specifying the Schema</a></h3>
<p>When case classes cannot be defined ahead of time (for example, the structure of records is encoded in a string, or a text dataset will be parsed and fields will be projected differently for different users), a <code>DataFrame</code> can be created programmatically with three steps.</p>
<ol>
<li>Create an RDD of <code>Row</code>s from the original RDD;</li>
<li>Create the schema represented by a <code>StructType</code> matching the structure of <code>Row</code>s in the RDD created in Step 1.</li>
<li>Apply the schema to the RDD of <code>Row</code>s via <code>createDataFrame</code> method provided by <code>SparkSession</code>.</li>
</ol>
<p>For example:</p>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-scala">import org.apache.spark.sql.Row

import org.apache.spark.sql.types._

// Create an RDD
val peopleRDD = spark.sparkContext.textFile(&quot;/datasets/sds/spark-examples/people.txt&quot;)
</code></pre>
<div class="output execute_result plain_result" execution_count="1">
<pre><code>import org.apache.spark.sql.Row
import org.apache.spark.sql.types._
peopleRDD: org.apache.spark.rdd.RDD[String] = /datasets/sds/spark-examples/people.txt MapPartitionsRDD[236] at textFile at command-2971213210278122:6
</code></pre>
</div>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-scala">// The schema is encoded in a string
val schemaString = &quot;name age&quot;
</code></pre>
<div class="output execute_result plain_result" execution_count="1">
<pre><code>schemaString: String = name age
</code></pre>
</div>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-scala">// Generate the schema based on the string of schema
val fields = schemaString.split(&quot; &quot;)
  .map(fieldName =&gt; StructField(fieldName, StringType, nullable = true))
</code></pre>
<div class="output execute_result plain_result" execution_count="1">
<pre><code>fields: Array[org.apache.spark.sql.types.StructField] = Array(StructField(name,StringType,true), StructField(age,StringType,true))
</code></pre>
</div>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-scala">val schema = StructType(fields)
</code></pre>
<div class="output execute_result plain_result" execution_count="1">
<pre><code>schema: org.apache.spark.sql.types.StructType = StructType(StructField(name,StringType,true),StructField(age,StringType,true))
</code></pre>
</div>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-scala">// Convert records of the RDD (people) to Rows
val rowRDD = peopleRDD
  .map(_.split(&quot;,&quot;))
  .map(attributes =&gt; Row(attributes(0), attributes(1).trim))
</code></pre>
<div class="output execute_result plain_result" execution_count="1">
<pre><code>rowRDD: org.apache.spark.rdd.RDD[org.apache.spark.sql.Row] = MapPartitionsRDD[238] at map at command-2971213210278126:4
</code></pre>
</div>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-scala">// Apply the schema to the RDD
val peopleDF = spark.createDataFrame(rowRDD, schema)
</code></pre>
<div class="output execute_result plain_result" execution_count="1">
<pre><code>peopleDF: org.apache.spark.sql.DataFrame = [name: string, age: string]
</code></pre>
</div>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-scala">peopleDF.show
</code></pre>
<div class="output execute_result plain_result" execution_count="1">
<pre><code>+-------+---+
|   name|age|
+-------+---+
|Michael| 29|
|   Andy| 30|
| Justin| 19|
+-------+---+
</code></pre>
</div>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-scala">// Creates a temporary view using the DataFrame
peopleDF.createOrReplaceTempView(&quot;people&quot;)
</code></pre>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-scala">// SQL can be run over a temporary view created using DataFrames
val results = spark.sql(&quot;SELECT name FROM people&quot;)
</code></pre>
<div class="output execute_result plain_result" execution_count="1">
<pre><code>results: org.apache.spark.sql.DataFrame = [name: string]
</code></pre>
</div>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-scala">results.show
</code></pre>
<div class="output execute_result plain_result" execution_count="1">
<pre><code>+-------+
|   name|
+-------+
|Michael|
|   Andy|
| Justin|
+-------+
</code></pre>
</div>
</div>
<div class="cell code" execution_count="1" scrolled="false">
<pre><code class="language-scala">// The results of SQL queries are DataFrames and support all the normal RDD operations
// The columns of a row in the result can be accessed by field index or by field name
results.map(attributes =&gt; &quot;Name: &quot; + attributes(0)).show()
</code></pre>
<div class="output execute_result plain_result" execution_count="1">
<pre><code>+-------------+
|        value|
+-------------+
|Name: Michael|
|   Name: Andy|
| Name: Justin|
+-------------+
</code></pre>
</div>
</div>
<div class="cell markdown">
<p>Find full example code at - https://raw.githubusercontent.com/apache/spark/master/examples/src/main/scala/org/apache/spark/examples/sql/SparkSQLExample.scala in the Spark repo.</p>
</div>
<div class="cell markdown">
<h2 id="scalar-functions"><a class="header" href="#scalar-functions">Scalar Functions</a></h2>
<p>Scalar functions are functions that return a single value per row, as opposed to aggregation functions, which return a value for a group of rows. Spark SQL supports a variety of <a href="https://spark.apache.org/docs/latest/sql-ref-functions.html#scalar-functions">Built-in Scalar Functions</a>. It also supports <a href="https://spark.apache.org/docs/latest/sql-ref-functions-udf-scalar.html">User Defined Scalar Functions</a>.</p>
</div>
<div class="cell markdown">
<h2 id="aggregate-functions"><a class="header" href="#aggregate-functions">Aggregate Functions</a></h2>
<p>Aggregate functions are functions that return a single value on a group of rows. The <a href="https://spark.apache.org/docs/latest/sql-ref-functions-builtin.html#aggregate-functions">Built-in Aggregation Functions</a> provide common aggregations such as <code>count()</code>, <code>countDistinct()</code>, <code>avg()</code>, <code>max()</code>, <code>min()</code>, etc. Users are not limited to the predefined aggregate functions and can create their own. For more details about user defined aggregate functions, please refer to the documentation of <a href="https://spark.apache.org/docs/latest/sql-ref-functions-udf-aggregate.html">User Defined Aggregate Functions</a>.</p>
</div>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../contents/000_1-sds-3-x-sql/007a_SparkSQLProgGuide_HW.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../../contents/000_1-sds-3-x-sql/007c_SparkSQLProgGuide_HW.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../contents/000_1-sds-3-x-sql/007a_SparkSQLProgGuide_HW.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../../contents/000_1-sds-3-x-sql/007c_SparkSQLProgGuide_HW.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="../../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
